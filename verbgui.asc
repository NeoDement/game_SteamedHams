// Gui Script
#define LANGUAGE_COUNT 8
#define ACT_COUNT 10  // Action Button Count (gMain)
#define MAX_DOORS 99  // How many doors accessed by door script
#define UNHANDLED_MSG_COUNT 21 // Amount of unhandled messages
#define DOORSTRING_COUNT 7     // Amount of door strings


/***********************************************************************
 * Distance(int x1, int y1, int x2, int y2)
 * Returns the distance between two coordinates
 * 
 ***********************************************************************/
static float Geometry::Distance(int x1, int y1, int x2, int y2)
{
  int dx = x1 - x2;
  int dy = y1 - y2;
  return Maths.Sqrt(IntToFloat(dx*dx+dy*dy));
}

/***********************************************************************
 * Offset(int point1, int point2)
 * Returns the offset between to two given values.
 * 
 ***********************************************************************/
static int Geometry::Offset(int point1, int point2)
{
  int value = point1 - point2;
  
  if (value<0) return -value;
  else return value;
}

// ========================== internal variables =============================
// Please do not edit these option directly anymore, but use the VerbGuiSettings settings script instead!



struct ActionButtonData {
    Action action;  // Array containg the related actions like eGA_LookAt
    int button; // Array containing the verb button Ids
    
    int button_graphic_normal[LANGUAGE_COUNT];     // contains the verb button sprites
    int button_graphic_highlight[LANGUAGE_COUNT];  // Contains the highlighted verb button sprites
    int action_l_keycode[LANGUAGE_COUNT]; // lower case keycodes for the verbs
    int action_u_keycode[LANGUAGE_COUNT]; // upper case keycodes for the verbs
    
};

ActionButtonData actionButtonData[ACT_COUNT];
  
  
struct VerbsData {
       
     
    eLanguage lang;           
    int actionLabelColorNormal;  
    int actionLabelColorHighlighted;
    int invUparrowONsprite;
    int invUparrowOFFsprite;
    int invUparrowHIsprite;
    int invDownarrowONsprite;      
    int invDownarrowOFFsprite;
    int invDownarrowHIsprite;
    int walkOffScreenOffset;
    bool approachCharInteract;
    bool NPCfacingPlayer;  
    bool objHotTalk;
    bool classicInvHandling;   
    bool classicGui;

    bool exitDoorDoubleclick; 
    bool exitExtensionDoubleclick; 
    bool runOnDoubleClick;
    int runCursorDistance;
    int runSpeedupRate;       //initialized in game_start

    int global_action;        // containing the current clicked action
    int default_action;       // default action (most likely walk-to)
    int alternative_action;   // right-click action
    int used_action;          // used_action = global_action, if not cancelled
    int AGSCursorMode;        // used mouse cursor mode

    String location_ex;       // hovered  location name including extension
    String location;          // hovered  location name excluding extension
    String location_clicked;  // clicked location name including extension
    String inv_ex_location;   // inventory name including extension
    String inv_location;      // inventory name location excluding extension

    String temp_location;     // needed to compare location & clicked location

    int location_type;        // the result of GetLocationType
    int location_id;          // on_mouse_click -> location id

    int player_walk_x_speed;  // Initial walking speed x coordinate
    int player_walk_y_speed;  // Initial walking speed y coordinate
    int player_ani_speed;     // Initial animation speed
    bool player_is_running;   // if character is currently running


    bool player_frozen;       // player can't move
    bool disabled_gui;        // GUI disabled
    

    
    String tresult;           // translated result of the action mode, eg. "Look at %s"
    String act_object;        // action_object - object used in action
    String act_item;          // inventory item to be used or given 
    int actionLabelWidth; // Width of the action label in the status bar


    InventoryItem*ItemGiven;        // Item given to a character
    char key_l_yes[LANGUAGE_COUNT]; // translated keys for yes (lower)
    char key_u_yes[LANGUAGE_COUNT]; // translated keys for yes (upper)
    char key_l_no[LANGUAGE_COUNT]; // translated keys for no (lower)
    char key_u_no[LANGUAGE_COUNT];  // translated keys for no (upper)

    int door_state[MAX_DOORS];// Array for the door script
    String door_strings[DOORSTRING_COUNT];   // default messages for the door script

    String unhandled_strings[UNHANDLED_MSG_COUNT]; // default unhandled messages

    // Default door sounds
    AudioClip*  openDoorSound,   
                closeDoorSound, 
                unlockDoorSound; 
    
    // Guis used by the module (we don't want to use global variables)
    GUI* guiAction;
    GUI* guiMain;
    GUI* guiPause;
    GUI* guiQuit;
    
    // Fonts used by the module (we don't want to use global names)
    FontType fontText;
    FontType fontTextOut;
    FontType fontSpeech;
    FontType fontOutlineSpeech;
    
    // Screenwidth and Screenhight
    int ScreenWidth;
    int ScreenHeight;
    
};
VerbsData verbsData;




            
// ============================= Helper functions ===========================================

/***********************************************************************
 * seti_VerbGuiOptions(this Verbs*, eVerbGuiOptions index,  int value) 
 * sets the template's options for the given index
 * 
 ***********************************************************************/
bool seti_VerbGuiOptions(static Verbs, eVerbGuiOptions index,  int value) 
{
  // Template Language
  if (index == eVerbGuiTemplateLanguage) verbsData.lang = value;
  
  // colour used in action bar
  if (index == eVerbGuiActionLabelColorNormal) verbsData.actionLabelColorNormal = value;
  
  // highlighted colour used in action bar
  if (index == eVerbGuiActionLabelColorHighlighted) verbsData.actionLabelColorHighlighted = value;
 
  
  // sprite slot of the upper inv arrow / normal
  if (index == eVerbGuiInvUparrowONsprite) verbsData.invUparrowONsprite = value;
  // sprite slot of the upper inv arrow / disabled
  if (index == eVerbGuiInvUparrowOFFsprite) verbsData.invUparrowOFFsprite = value;
  // sprite slot of the upper inv arrow / highlighted
  if (index == eVerbGuiInvUparrowHIsprite) verbsData.invUparrowHIsprite = value;
  
  
  // sprite slot of the lower inv arrow / normal
  if (index == eVerbGuiInvDownarrowONsprite) verbsData.invDownarrowONsprite = value;
  // sprite slot of the lower inv arrow / disabled
  if (index == eVerbGuiInvDownarrowOFFsprite) verbsData.invDownarrowOFFsprite = value;
  // sprite slot of the lower inv arrow / highlighted
  if (index == eVerbGuiInvDownarrowHIsprite) verbsData.invDownarrowHIsprite = value;
  
  // offset used by WalkOffScreen and exit extensions
  if (index == eVerbGuiWalkOffScreenOffset) verbsData.walkOffScreenOffset = value;
  
  // walk to character before starting interaction
  if (index == eVerbGuiApproachCharInteract) verbsData.approachCharInteract = value;
  
  // Non playable characters are facing the player before talk-to and give-to
  if (index == eVerbGuiNPCfacingPlayer) verbsData.NPCfacingPlayer = value;
  
  // Enable Talk to Objects and Hotspots
  if (index == eVerbGuiObjHotTalk)  verbsData.objHotTalk = value;
  
  // turned on: right-click on inv items is lookat, left-click is use
  // all other extensions will be ignored
  if (index == eVerbGuiClassicInvHandling)  verbsData.classicInvHandling = value;
  
  // action bar is fixed like in classic SCUMM games among other things
  if (index == eVerbGuiClassicGui)  verbsData.classicGui = value;
  
  // Doubleclick on open doors changes room instantly
  if (index == eVerbGuiExitDoorDoubleclick)  verbsData.exitDoorDoubleclick = value;
  
  // Doubleclick on anything with an exit extension
  if (index == eVerbGuiExitExtensionDoubleclick)  verbsData.exitExtensionDoubleclick = value;
  
  // Character speed is doubled on doubleclick
  if (index == eVerbGuiRunOnDoubleClick)  verbsData.runOnDoubleClick = value;
  
  // Distance between mouse cursor and player until running begins
  if (index == eVerbGuiRunCursorDistance)  verbsData.runCursorDistance = value;
  
  // multiplied to the player movement speed, while running
  // 1 = no speedup at all, 2 = double speed and so on
  if (index == eVerbGuiRunSpeedupRate)  verbsData.runSpeedupRate = value;

}

/***********************************************************************
 * geti_VerbGuiOptions(this Verbs*, eVerbGuiOptions index)
 * Returns the template's options for the given index
 * 
 ***********************************************************************/
int geti_VerbGuiOptions(static Verbs, eVerbGuiOptions index) 
{
  if (index == eVerbGuiTemplateLanguage) return verbsData.lang;
  if (index == eVerbGuiActionLabelColorNormal) return verbsData.actionLabelColorNormal;
  if (index == eVerbGuiActionLabelColorHighlighted) return verbsData.actionLabelColorHighlighted;
  if (index == eVerbGuiInvUparrowONsprite) return verbsData.invUparrowONsprite;
  if (index == eVerbGuiInvUparrowOFFsprite) return verbsData.invUparrowOFFsprite;
  if (index == eVerbGuiInvUparrowHIsprite) return verbsData.invUparrowHIsprite;
  if (index == eVerbGuiInvDownarrowONsprite) return verbsData.invDownarrowONsprite;
  if (index == eVerbGuiInvDownarrowOFFsprite) return verbsData.invDownarrowOFFsprite;
  if (index == eVerbGuiInvDownarrowHIsprite) return verbsData.invDownarrowHIsprite;
  if (index == eVerbGuiWalkOffScreenOffset) return verbsData.walkOffScreenOffset;
  if (index == eVerbGuiApproachCharInteract) return verbsData.approachCharInteract;
  if (index == eVerbGuiNPCfacingPlayer) return verbsData.NPCfacingPlayer;
  if (index == eVerbGuiObjHotTalk) return  verbsData.objHotTalk;
  if (index == eVerbGuiClassicInvHandling) return  verbsData.classicInvHandling;
  if (index == eVerbGuiClassicGui) return  verbsData.classicGui;
  if (index == eVerbGuiExitDoorDoubleclick) return  verbsData.exitDoorDoubleclick;
  if (index == eVerbGuiExitExtensionDoubleclick) return  verbsData.exitExtensionDoubleclick;
  if (index == eVerbGuiRunOnDoubleClick) return  verbsData.runOnDoubleClick;
  if (index == eVerbGuiRunCursorDistance) return  verbsData.runCursorDistance;
  if (index == eVerbGuiRunSpeedupRate) return  verbsData.runSpeedupRate;
  return 0;
}

/***********************************************************************
 * seti_VerbGuiUnhandled(this Verbs*, eVerbGuiOptions index,  int value) 
 * sets the messages for the unhandled events
 * 
 ***********************************************************************/
bool seti_VerbGuiUnhandled(static Verbs, eVerbGuiUnhandled index, String value) 
{
  verbsData.unhandled_strings[index] = value;
}

/***********************************************************************
 * geti_VerbGuiUnhandled(this Verbs*, eVerbGuiOptions index,  int value) 
 * gets the messages for the unhandled events
 * 
 ***********************************************************************/
String geti_VerbGuiUnhandled(static Verbs, eVerbGuiUnhandled index) 
{
  return verbsData.unhandled_strings[index];
}


/***********************************************************************
 * BindGuis(GUI* _gAction, GUI* _gMain, GUI* _gPause, GUI* _gQuit) 
 * binds the according GUIs to the script. It defines, which GUIs will
 *   be used for displaying verbs and so on.
 * 
 ***********************************************************************/
static void Verbs::BindGuis(GUI* _gAction, GUI* _gMain, GUI* _gPause, GUI* _gQuit)
{
    verbsData.guiAction     = _gAction;
    verbsData.guiMain       = _gMain;
    verbsData.guiPause      = _gPause;
    verbsData.guiQuit       = _gQuit;
}

/***********************************************************************
 * SetFonts(FontType fontText, FontType fontTextOut, FontType fontSpeech, FontType fontOutlineSpeech)
 * defines the fonts used be the template
 * 
 ***********************************************************************/
static void Verbs::SetFonts(FontType fontText, FontType fontTextOut, FontType fontSpeech, FontType fontOutlineSpeech)
{
    verbsData.fontText          = fontText;
    verbsData.fontTextOut       = fontTextOut;
    verbsData.fontSpeech        = fontSpeech;
    verbsData.fontOutlineSpeech = fontOutlineSpeech;
}

/***********************************************************************
 * GetButtonAction(int action)
 * Returns the connected action of a verb button.
 * 
 ***********************************************************************/
static int Verbs::GetButtonAction(Button* button) 
{
  if (button.OwningGUI != verbsData.guiMain) {
      AbortGame("This button is not part of the Tumbleweed verbs GUI");
  }
  
  for (int action=0; action< ACT_COUNT; action++) {
      if (actionButtonData[action].button == button.ID) {
            return actionButtonData[action].action;
      }
  }
  AbortGame("Could not find the action corresonding to this button.");
}

/***********************************************************************
 * DisableGui()
 * This functions disables the GUI (but does not necessarily hides it)
 * 
 ***********************************************************************/
static void Verbs::DisableGui()
{
  verbsData.disabled_gui=true;
}

/***********************************************************************
 * EnableGui()
 * This functions enables the GUI (but does not necessarily makes it visible).
 * 
 ***********************************************************************/
static void Verbs::EnableGui()
{
  verbsData.disabled_gui=false;
}

/***********************************************************************
 * IsGuiDisabled()
 * Returns true, if the GUI is currently disabled, false otherwise
 * 
 ***********************************************************************/
static bool Verbs::IsGuiDisabled() 
{
  return verbsData.disabled_gui;
}


/***********************************************************************
 * ShowGui()
 * Shows the verbs GUI and enables it
 * 
 ***********************************************************************/
static void Verbs::ShowGui()
{
  Verbs.EnableGui();
  verbsData.guiMain.Visible=true;
  verbsData.guiAction.Visible=true;
  Wait(1);
}

/***********************************************************************
 * ShowGui()
 * Hides the verbs GUI and disables it
 * 
 ***********************************************************************/
static void Verbs::HideGui()
{
  Verbs.DisableGui();
  verbsData.guiMain.Visible=false;
  verbsData.guiAction.Visible=false;
}

/***********************************************************************
 * IsGuiDisabled()
 * Returns true, if the GUI is currently visibale, false otherwise
 * 
 ***********************************************************************/
static bool Verbs::IsGuiVisible()
{
   return verbsData.guiMain.Visible;
}


/***********************************************************************
 * HandleInvArrows() 
 * Takes care of showing or hiding the inventory scroll sprites
 *
 ***********************************************************************/
static void Verbs::HandleInvArrows()
{
  // change the arrows in the inventory to show if you
  // can scroll the inventory:
  if (invMain.TopItem > 0) {
    // if inventory can scroll up
    btnInvUp.NormalGraphic    = verbsData.invUparrowONsprite;
    btnInvUp.MouseOverGraphic = verbsData.invUparrowHIsprite;
    
    if (InventoryItem.GetAtScreenXY(verbsData.guiMain.X + invMain.X + 1, verbsData.guiMain.Y + invMain.Y + 1) == null) invMain.TopItem -= invMain.ItemsPerRow;
  }
  else { 
    btnInvUp.NormalGraphic    = verbsData.invUparrowOFFsprite;
    btnInvUp.MouseOverGraphic = verbsData.invUparrowOFFsprite;
  }
  //if inv can scroll down
  if (invMain.TopItem < invMain.ItemCount-(invMain.ItemsPerRow * invMain.RowCount)) { 
    btnInvDown.NormalGraphic    = verbsData.invDownarrowONsprite;
    btnInvDown.MouseOverGraphic = verbsData.invDownarrowHIsprite;
  }
  else{
    btnInvDown.NormalGraphic    = verbsData.invDownarrowOFFsprite;
    btnInvDown.MouseOverGraphic = verbsData.invDownarrowOFFsprite;
  }
}

// ============================= door init functions ===========================================
/***********************************************************************
 * seti_VerbGuiUnhandled(this Verbs*, eVerbGuiOptions index,  int value) 
 * sets the messages for the unhandled events
 * 
 ***********************************************************************/
bool seti_DoorStrings(static Doors, eDoorStrings index, String value) 
{
  if (!String.IsNullOrEmpty(value)) verbsData.door_strings[index] = value;
}

/***********************************************************************
 * geti_VerbGuiUnhandled(this Verbs*, eVerbGuiOptions index,  int value) 
 * gets the messages for the unhandled events
 * 
 ***********************************************************************/
String geti_DoorStrings(static Doors, eDoorStrings index) 
{
  return verbsData.door_strings[index];
}
/***********************************************************************
 * SetDoorState(int door_id, int value) 
 * Call this function to set a door state for the given door_id. A door can have 3 different states:
 *  0 = The door is closed 
 *  1 = The door is open 
 *  2 = The door is closed and locked 
 * 
 ***********************************************************************/
static void Doors::SetDoorState(int door_id, int value) 
{
  verbsData.door_state[door_id] = value;
}

/***********************************************************************
 * GetDoorState(int door_id) 
 * Returns the current state of a door.
 * 
 ***********************************************************************/
static int Doors::GetDoorState(int door_id) 
{
  return verbsData.door_state[door_id];
}

/***********************************************************************
 * InitObject (int door_id, int obj)
 * Used to set up the corresponding object, used by the door with the given id. 
 * If the state of the door is closed, the object will be invisible. 
 * Otherwise, the object will be shown. The object stays unclickable all the time.
 *
 ***********************************************************************/
static void Doors::InitObject (int door_id, int obj)
{
  if (Doors.GetDoorState(door_id) == 1) {
    object[obj].Visible=true;
    object[obj].Clickable=false;
  }
  else { 
    object[obj].Visible=false;
    object[obj].Clickable=false;
  }
}


// ============================= verb action functions ===========================================

/***********************************************************************
 * TranslateAction(int action, int tr_lang)
 * This function defines the text for the verb buttons, e.g. if you click on the talk verb button, 
 * "Talk to" is being displayed in the action/status bar. The second parameter defines the returned language. 
 * If you want to customize this text, you have to edit this function.
 * 
 ***********************************************************************/
static void Verbs::TranslateAction(int action, int tr_lang) 
{
  if (tr_lang == eLangDE) {
    if (action == eGA_WalkTo)        verbsData.tresult="Gehe zu %s";
    else if (action == eGA_LookAt)   verbsData.tresult="Schau %s an";
    else if (action == eGA_TalkTo)   verbsData.tresult="Rede mit %s";
    else if (action == eGA_GiveTo) {
      if (verbsData.act_item.Length > 0)       verbsData.tresult="Gib !s an %s";
      else                           verbsData.tresult="Gib %s";
    }
    else if (action == eGA_PickUp)   verbsData.tresult="Nimm %s";
    else if (action == eGA_Use) {
      if (verbsData.act_item.Length > 0)       verbsData.tresult="Benutze !s mit %s";
      else                           verbsData.tresult="Benutze %s";
    }
    else if (action == eGA_Open)     verbsData.tresult="Öffne %s";
    else if (action == eGA_Close)    verbsData.tresult="Schließe %s";
    else if (action == eGA_Push)     verbsData.tresult="Drücke %s";
    else if (action == eGA_Pull)     verbsData.tresult="Ziehe %s";
    else verbsData.tresult=" ";   
  }
  else if (tr_lang == eLangES) {
    if (action == eGA_WalkTo)        verbsData.tresult="Ir a %s";
    else if (action == eGA_LookAt)   verbsData.tresult="Mirar %s";
    else if (action == eGA_TalkTo)   verbsData.tresult="Hablar con %s";
    else if (action == eGA_GiveTo) {
      if (verbsData.act_item.Length > 0)       verbsData.tresult="Dar !s a %s";
      else                           verbsData.tresult="Dar %s";
    }
    else if (action == eGA_PickUp)   verbsData.tresult="Coger %s";
    else if (action == eGA_Use) {
      if (verbsData.act_item.Length > 0)       verbsData.tresult="Usar !s con %s";
      else                           verbsData.tresult="Usar %s";
    }
    else if (action == eGA_Open)     verbsData.tresult="Abrir %s";
    else if (action == eGA_Close)    verbsData.tresult="Cerrar %s";
    else if (action == eGA_Push)     verbsData.tresult="Empujar %s";
    else if (action == eGA_Pull)     verbsData.tresult="Tirar de %s";
    else verbsData.tresult=" ";    
  }
  else if (tr_lang == eLangFR) {
    if (action == eGA_WalkTo)        verbsData.tresult="Aller vers %s";
    else if (action == eGA_LookAt)   verbsData.tresult="Regarder %s";
    else if (action == eGA_TalkTo)   verbsData.tresult="Parler à %s";
    else if (action == eGA_GiveTo) {
      if (verbsData.act_item.Length>0)         verbsData.tresult="Donner !s à %s";
      else                           verbsData.tresult="Donner %s";
    }
    else if (action == eGA_PickUp)   verbsData.tresult="Prendre %s";
    else if (action == eGA_Use) {
      if (verbsData.act_item.Length>0)         verbsData.tresult="Utiliser !s sur %s";
      else                           verbsData.tresult="Utiliser %s";
    }
    else if (action == eGA_Open)     verbsData.tresult="Ouvrir %s";
    else if (action == eGA_Close)    verbsData.tresult="Fermer %s";
    else if (action == eGA_Push)     verbsData.tresult="Pousser %s";
    else if (action == eGA_Pull)     verbsData.tresult="Tirer %s";
    else verbsData.tresult=" "; 
  }  
  else if (tr_lang == eLangIT) {
    if (action == eGA_WalkTo)        verbsData.tresult="Vai a %s";
    else if (action == eGA_LookAt)   verbsData.tresult="Esamina %s";
    else if (action == eGA_TalkTo)   verbsData.tresult="Parla con %s";
    else if (action == eGA_GiveTo) {
    if (verbsData.act_item.Length > 0)         verbsData.tresult="Dai !s a %s";
    else                             verbsData.tresult="Dai %s";
    }
    else if (action == eGA_PickUp)   verbsData.tresult="Raccogli %s";
    else if (action == eGA_Use) {
    if (verbsData.act_item.Length > 0)         verbsData.tresult="Usa !s con %s";
    else                             verbsData.tresult="Usa %s";
    }
    else if (action == eGA_Open)     verbsData.tresult="Apri %s";
    else if (action == eGA_Close)    verbsData.tresult="Ferma %s";
    else if (action == eGA_Push)     verbsData.tresult="Premi %s";
    else if (action == eGA_Pull)     verbsData.tresult="Tira %s";
    else verbsData.tresult=" "; 
  }
  else if (tr_lang == eLangPT) {
    if (action == eGA_WalkTo)        verbsData.tresult="Ir para %s";
    else if (action == eGA_LookAt)   verbsData.tresult="Olhar para %s";
    else if (action == eGA_TalkTo)   verbsData.tresult="Falar com %s";
    else if (action == eGA_GiveTo) {
    if (verbsData.act_item.Length > 0)         verbsData.tresult="Dar !s a %s";
    else                             verbsData.tresult="Dar %s";
    }
    else if (action == eGA_PickUp)   verbsData.tresult="Apanhar %s";
    else if (action == eGA_Use) {
    if (verbsData.act_item.Length > 0)         verbsData.tresult="Usar !s com %s";
    else                             verbsData.tresult="Usar %s";
    }
    else if (action == eGA_Open)     verbsData.tresult="Abrir %s";
    else if (action == eGA_Close)    verbsData.tresult="Fechar %s";
    else if (action == eGA_Push)     verbsData.tresult="Empurrar %s";
    else if (action == eGA_Pull)     verbsData.tresult="Puxar %s";
    else verbsData.tresult=" "; 
  }
  else if (tr_lang == eLangNL) {
    if (action == eGA_WalkTo)        verbsData.tresult="Ga naar %s";
    else if (action == eGA_LookAt)   verbsData.tresult="Bekijk %s";
    else if (action == eGA_TalkTo)   verbsData.tresult="Praat met %s";
    else if (action == eGA_GiveTo) {
    if (verbsData.act_item.Length>0)           verbsData.tresult="Geef !s aan %s";
    else                             verbsData.tresult="Geef %s";
    }
    else if (action == eGA_PickUp)   verbsData.tresult="Pak %s";
    else if (action == eGA_Use) {
    if (verbsData.act_item.Length>0)           verbsData.tresult="Gebruik !s met %s";
    else                             verbsData.tresult="Gebruik %s";
    }
    else if (action == eGA_Open)     verbsData.tresult="Open %s";
    else if (action == eGA_Close)    verbsData.tresult="Sluit %s";
    else if (action == eGA_Push)     verbsData.tresult="Duw %s";
    else if (action == eGA_Pull)     verbsData.tresult="Trek %s";
    else verbsData.tresult=" "; 
  }   
  else {
    if (action == eGA_WalkTo)        verbsData.tresult="Walk to %s";
    else if (action == eGA_LookAt)   verbsData.tresult="Look at %s";
    else if (action == eGA_TalkTo)   verbsData.tresult="Talk to %s";
    else if (action == eGA_GiveTo) {
      if (verbsData.act_item.Length > 0)       verbsData.tresult="Give !s to %s";
      else                           verbsData.tresult="Give %s";
    }
    else if (action == eGA_PickUp)   verbsData.tresult="Pick up %s";
    else if (action == eGA_Use) {
      if (verbsData.act_item.Length > 0)       verbsData.tresult="Use !s with %s";
      else                           verbsData.tresult="Use %s";
    }
    else if (action == eGA_Open)     verbsData.tresult="Open %s";
    else if (action == eGA_Close)    verbsData.tresult="Close %s";
    else if (action == eGA_Push)     verbsData.tresult="Push %s";
    else if (action == eGA_Pull)     verbsData.tresult="Pull %s";
    else verbsData.tresult=" ";    
  }
  // fill object and item into action template
  verbsData.tresult = GetTranslation(verbsData.tresult);
  int ip = verbsData.tresult.IndexOf("!s");
  if (ip >= 0) {
    int op  = verbsData.tresult.Contains("%s");
    verbsData.tresult = verbsData.tresult.ReplaceCharAt(ip, '%');
    if (ip < op) verbsData.tresult=String.Format(verbsData.tresult, verbsData.act_item, verbsData.act_object);
    else         verbsData.tresult=String.Format(verbsData.tresult, verbsData.act_object, verbsData.act_item);
  }
  else {
    if (verbsData.act_object == null) verbsData.act_object = "";
    verbsData.tresult=String.Format(verbsData.tresult, verbsData.act_object);
  }
}

/***********************************************************************
 * IsAction(Action test_action) 
 * Used to check, if the current action is the one, given in the parameter.
 * 
 ***********************************************************************/
static bool Verbs::IsAction(Action test_action) 
{
  return  verbsData.global_action == test_action;
}

/***********************************************************************
 * UsedAction(Action test_action) 
 * Used to determine, which action has been selected by the player. 
 * Instead of checking cursor modes, this function is used.
 * 
 ***********************************************************************/
static bool Verbs::UsedAction(Action test_action) 
{
  return (( verbsData.used_action == test_action) && ( verbsData.AGSCursorMode != eModeUseinv)) || 
         ((test_action == eGA_UseInv)  && ( verbsData.used_action == eGA_Use) && ( verbsData.AGSCursorMode == eModeUseinv)) || 
         ((test_action == eGA_GiveTo)  && ( verbsData.used_action == eGA_GiveTo) && ( verbsData.AGSCursorMode == eModeUseinv) && verbsData.ItemGiven!=null);
}

/***********************************************************************
 * SetAction(Action new_action) 
 * Since the cursor modes are bypassed, this function defines the current action. 
 * Among other things, this function is called by clicking a verb button.
 * 
 ***********************************************************************/
static void Verbs::SetAction(Action new_action) 
{
  // set default action
  if (new_action == eGA_Default) new_action= verbsData.default_action;
  // set corresponding cursormode
       if (new_action == eGA_WalkTo) mouse.Mode=eModeUsermode2;
  else if (new_action == eGA_LookAt) mouse.Mode=eModeLookat;
  else if (new_action == eGA_TalkTo) mouse.Mode=eModeTalkto;
  else if (new_action == eGA_GiveTo) mouse.Mode=eModeInteract;
  else if (new_action == eGA_PickUp) mouse.Mode=eModePickup;
  else if (new_action == eGA_Use)    mouse.Mode=eModeInteract;
  else if (new_action == eGA_Open)   mouse.Mode=eModeUsermode1;
  else if (new_action == eGA_Close)  mouse.Mode=eModeUsermode1;
  else if (new_action == eGA_Push)   mouse.Mode=eModeUsermode1;
  else if (new_action == eGA_Pull)   mouse.Mode=eModeUsermode1;
  // save action
   verbsData.global_action=new_action;
}

/***********************************************************************
 * SetDefaultAction(Action def_action) 
 * Used to define, which action is being used, if no verb has been clicked. 
 * Usually this is “walk to”.
 * 
 ***********************************************************************/
static void Verbs::SetDefaultAction(Action def_action) 
{
   verbsData.default_action = def_action;
  Verbs.SetAction(eGA_Default);
}


/***********************************************************************
 * Action GetUsedAction() 
 * Returns directly which action was selected by the player
 * 
 ***********************************************************************/

static Action Verbs::GetUsedAction() {
  if(Verbs.UsedAction(eGA_WalkTo)){
    return eGA_WalkTo;
  }
  else if(Verbs.UsedAction(eGA_LookAt)){
    return eGA_LookAt;
  }
  else if(Verbs.UsedAction(eGA_TalkTo)){
    return eGA_TalkTo;
  }
  else if(Verbs.UsedAction(eGA_GiveTo)){
    return eGA_GiveTo;
  }
  else if(Verbs.UsedAction(eGA_PickUp)){
    return eGA_PickUp;
  }
  else if(Verbs.UsedAction(eGA_Use)){
    return eGA_Use;
  }
  else if(Verbs.UsedAction(eGA_UseInv)){
    return eGA_UseInv;
  }
  else if(Verbs.UsedAction(eGA_Open)){
    return eGA_Open;
  }
  else if(Verbs.UsedAction(eGA_Close)){
    return eGA_Close;
  }
  else if(Verbs.UsedAction(eGA_Push)){
    return eGA_Push;
  }
  else if(Verbs.UsedAction(eGA_Pull)){
    return eGA_Pull;
  }
  return -1;
}

/***********************************************************************
 * Action GetItemGiven() 
 * Returns the item that has been given by the player. It's more or less player.ActiveInventory with more subtle logic
 * 
 ***********************************************************************/
 

static InventoryItem* Verbs::GetItemGiven()
{
    return verbsData.ItemGiven;
}
  
  

// ============================= GlobalCondition ===========================================

/***********************************************************************
 * GlobalCondition(eGlobCond condition)
 * Used to check for conditions that are used many times in the script. 
 * For example, it’s used to check, if the mouse cursor is in the inventory and the mode walk or pickup are selected. 
 * Returns 1, if the condition is true and 0 otherwise.
 * 
 ***********************************************************************/
static int Verbs::GlobalCondition(eGlobCond condition) 
{
  // here are some conditions that are used many times in the script
  int cond;
  InventoryItem*ii = InventoryItem.GetAtScreenXY(mouse.x, mouse.y);
  GUIControl*gc    = GUIControl.GetAtScreenXY(mouse.x, mouse.y);
  int gcid = -1;
  if (gc != null) gcid = gc.ID;
  
  // if the mouse is in the inventory and mode Walk is selected
  if (condition == eGlob_MouseInvWalk ) {
    cond = (ii != null && (Verbs.IsAction(eGA_WalkTo)));
  }
  // if the mouse is in the inventory and mode Pickup is selected
  else if (condition == eGlob_MouseInvPickup) {
    cond = (ii != null && (Verbs.IsAction(eGA_PickUp)));
  }
  // if the mode is useinv and the mouse is over the active inv (like "use knife on knife")
  else if (condition == eGlob_InvOnInv) {
    cond =(player.ActiveInventory == ii && Mouse.Mode == eModeUseinv);
  } 
  // if the mode is talk or "Give", and the mouse isnt over a character
  else if (condition == eGlob_GiveTalkNoChar) {
    
    if ( verbsData.objHotTalk && Verbs.IsAction(eGA_TalkTo) ) {
      cond = false;     
    }  
    else {
      cond =((Verbs.IsAction(eGA_TalkTo) || (Verbs.IsAction(eGA_GiveTo) && (Mouse.Mode == eModeUseinv))) && (GetLocationType(mouse.x, mouse.y) != eLocationCharacter));
    }
  }
    
  // if its GIVE and the mouse isnt over a inv.item
  else if (condition == eGlob_GiveNoInv) 
    cond = ((Mouse.Mode == eModeInteract) && Verbs.IsAction(eGA_GiveTo) && (ii == null));
  
  // if the mouse is in the inventory and mode TalkTo is selected 
  else if (condition == eGlob_InvTalk)
    cond =  (ii != null && (Verbs.IsAction(eGA_TalkTo)));
  
  return cond;
}

// ============================= Verb Extensions and actions ===========================================

/***********************************************************************
 * ExtensionEx(int index, String name)
 * Returns the n-th extension of the given string. 
 * 
 ***********************************************************************/
static char Verbs::ExtensionEx(int index, String name)
{
  //returns the extension in the position 'index' of the string 'name'.
  //returns 0 if the name has no extension or if you passed an empty string.
  if (name.Length == 0) return 0;//if you passed an empty string
  int pos;
  pos = name.IndexOf(">");
  if (pos == -1) return 0;
  else if (pos+index<name.Length) return name.Chars[pos+index];
  else return 0;
}

/***********************************************************************
 * Extension()
 * Returns the first extention of the location
 * 
 ***********************************************************************/
static char Verbs::Extension()
{
  // Check the (first) extension (>*) of a string
  return Verbs.ExtensionEx(1, verbsData.location);
}

/***********************************************************************
 * RemoveExtension()
 * Used to remove the extension from a location (Hotspots, Objects etc.), so it doesn’t get displayed in the status bar.
 * 
 ***********************************************************************/
static int Verbs::RemoveExtension()
{
  //removes the extension of a string  
  int pos = verbsData.location.IndexOf(">");
  int length = verbsData.location.Length;
  if (Verbs.Extension() != 0) verbsData.location = verbsData.location.Truncate(pos);
  return pos;
}

/***********************************************************************
 * AddExtension()
 * Used to add a default extension in case the location doesn’t have one.
 * 
 ***********************************************************************/
static void Verbs::AddExtension(char extension) 
{
  //adds an extension to a thing that doesn't have one
  int length=verbsData.location.Length;
  if (Verbs.Extension() == 0) {
    verbsData.location=verbsData.location.Append(">n");
    verbsData.location=verbsData.location.ReplaceCharAt(length+1, extension);
  }
}

/***********************************************************************
 * SetAlternativeAction(char extension, Action alt_action)
 * This function makes the right-click shortcuts work. 
 * If you use extensions like “>p” (e.g. pickup), this function makes sure, that the correct verb button is highlighted.
 * 
 ***********************************************************************/
static void Verbs::SetAlternativeAction(char extension, Action alt_action) 
{
  if (alt_action == eGA_Default) {
    if (Verbs.Extension() == extension)
       verbsData.alternative_action = alt_action;
  }
  else {
    int button          = actionButtonData[alt_action].button;
    int normalbuttonpic = actionButtonData[alt_action].button_graphic_normal[verbsData.lang];
    int overbuttonpic   = actionButtonData[alt_action].button_graphic_highlight[verbsData.lang];
    
    // used for setting the default action given the extension.
    GUIControl*gc = verbsData.guiMain.Controls[button];
    Button*b = gc.AsButton;
    
    if (Verbs.Extension() == extension) {
      b.NormalGraphic = overbuttonpic;
       verbsData.alternative_action = alt_action;
    }
    else b.NormalGraphic = normalbuttonpic;
    b.MouseOverGraphic = overbuttonpic;
  }
}

/***********************************************************************
 * OpenCloseExtension(int door_id)
 * Used in combination with the door scripts. This function returns a close extension, if the door with the given id is open and vice versa.
 * 
 ***********************************************************************/
static void Verbs::OpenCloseExtension(int door_id) 
{
  if ((Doors.GetDoorState(door_id)==0) || (Doors.GetDoorState(door_id)==2)) Verbs.AddExtension('o');
  else Verbs.AddExtension('c');
}

/***********************************************************************
 * VariableExtensions(
 * This function is called, if you have have set "v" as an extension for a certain location. 
 * Currently it is used for the OpenClose extension, but of course you can add your own variable extensions here, 
 * for example "turn on / turn off"
 * 
 ***********************************************************************/
static void Verbs::VariableExtensions() 
{

  //player.Say(

  //sanity check this and implement it
  if (OvenHasBeenOpened == false)
  {
    
    if (object[0].Visible == true) //window is open
    {
      //action should be "close"
      Verbs.AddExtension('c'); 
    }
    else if (object[0].Visible == false) //window is closed
    {
      //action should be "open"
      Verbs.AddExtension('o'); 
    }
    
  }
    else if (OvenHasBeenOpened == true)
    {
      
      //player.Say("Debug!! oven NOT opened");
      if (WindowHasBeenLookedOut == false)
      {
        //action should be "look"
        Verbs.AddExtension('l'); 
      }
      else if (WindowHasBeenLookedOut == true)
      {
        if (object[0].Visible == true) //window is open
        {
          if (player.HasInventory(iBurger) == false)
          {
            //action should be "use"
            Verbs.AddExtension('u'); 
          }
          else
          {
            //action should be "close"          //all tasks are done so window is just a toggle now
            Verbs.AddExtension('c'); 
          }
        }
        else if (object[0].Visible == false) //window is closed
        {
          //action should be "open"
          Verbs.AddExtension('o'); 
        }
    
  }
}
 
 
  /*
  // define here, which things will use a variable extension (>v)
  // by default, it's only used for doors.
  int r = player.Room;
  Object*oo = Object.GetAtScreenXY(mouse.x, mouse.y);
  int o=0;
  if (oo != null) o = oo.ID;
  Hotspot*hh = Hotspot.GetAtScreenXY(mouse.x, mouse.y);
  int h = hh.ID;
  
  // Other possible extensions could be: Turn On/Turn Off
  
  // Open/Close Extension:
  // Room | Hotspot |(Door_id)
 // if (r==4 && h == 2)  Verbs.OpenCloseExtension (10);
   if (r==4 && h == 2)  Verbs.AddExtension('c');
  //else if (r==2  && h == 2)  OpenCloseExtension (3);  
*/
}

/***********************************************************************
 * CheckDefaultAction()
 * This function checks for a given extension in hotspots, objects and characters. 
 * If there isn’t an extension, a default action is given, e.g. “Talk to” if the mouse is over a character. 
 * In case of a given extension, the default actions are being overridden.
 * 
 ***********************************************************************/
static void Verbs::CheckDefaultAction() 
{
  // you could want to change which extension activates which default action, or which button sprite
  // it changes. The extensions are characters, so remember enclose them in single quotes ' , not double quotes ".
  int x = mouse.x;
  int y = mouse.y;
  
  verbsData.location = Game.GetLocationName(x, y);
   verbsData.location_ex = verbsData.location;
  
  
  // Setting default modes if the thing has no extension:
  if (Verbs.Extension() == 0 ) {
    if (GetLocationType(x, y) == eLocationCharacter) // if it is a character
      Verbs.AddExtension('t'); // set default action "talk to"
    else if ((GetLocationType(x, y) != eLocationNothing) || (InventoryItem.GetAtScreenXY(x, y)!=null))
      // if its an inv item, a hotspot or an object
      Verbs.AddExtension('l'); // set default action "look at"
    else
      Verbs.AddExtension('n'); // set default action "none"
  }
  else if (Verbs.Extension()=='v') { // if the default action depends on some events
    Verbs.RemoveExtension();
    Verbs.VariableExtensions();
  }
  if (Verbs.GlobalCondition(eGlob_InvOnInv) || (! verbsData.objHotTalk && Verbs.GlobalCondition(eGlob_GiveTalkNoChar)) || Verbs.GlobalCondition(eGlob_GiveNoInv) ) {
    //Dont send the name of the hotspt/obj/char/inv to the action bar and set default action "none"
    if (!Verbs.GlobalCondition(eGlob_InvTalk)) verbsData.location=">n";
  }
  
  verbsData.inv_ex_location=verbsData.location;
  
  // Set "Look" as default action for Inv items
  if ((Verbs.Extension()=='u') && (InventoryItem.GetAtScreenXY(x, y) != null)) {
    // it's an inv item
    Verbs.RemoveExtension();
    Verbs.AddExtension('l'); // set default action "look at"
  }
  
  //Verbs.SetAlternativeAction('w', eGA_Default);
  //Verbs.SetAlternativeAction('w', eGA_WalkTo);
  
  //setting 'w' to "WalkTo" doesnt work for whatever reason (out of bounds?) so setting it up in global script instead
  
  Verbs.SetAlternativeAction('g', eGA_GiveTo);
  Verbs.SetAlternativeAction('p', eGA_PickUp);
  Verbs.SetAlternativeAction('u', eGA_Use);
  Verbs.SetAlternativeAction('o', eGA_Open);
  Verbs.SetAlternativeAction('l', eGA_LookAt);
  Verbs.SetAlternativeAction('s', eGA_Push);
  Verbs.SetAlternativeAction('c', eGA_Close);
  Verbs.SetAlternativeAction('t', eGA_TalkTo);
  Verbs.SetAlternativeAction('y', eGA_Pull);  
  Verbs.RemoveExtension();
  verbsData.inv_location = verbsData.location;
}
// ============================= ActionBar ===========================================


/***********************************************************************
 * AdjustActionBarPosition()
 * Moves the action label above the mouse cursor
 * 
 ***********************************************************************/
static void Verbs::AdjustActionBarPosition()
{
  int actionLabelHalf = verbsData.actionLabelWidth / 2;
  int xpos = mouse.x - actionLabelHalf ;
  int ypos = mouse.y - Game.SpriteHeight[mouse.GetModeGraphic(mouse.Mode)] - 4;

  if (xpos + verbsData.actionLabelWidth >= verbsData.ScreenWidth) xpos = verbsData.ScreenWidth - verbsData.actionLabelWidth;
  else if (xpos < 0) xpos = 0;
  
  if (ypos < 0 ) ypos = 0;
  
  lblAction.X = xpos;
  lblAction.Y = ypos;
  lblAction.Width = verbsData.actionLabelWidth;
  
}

/***********************************************************************
 * UpdateActionBar()
 * This function is used to show and update the status bar. 
 * It checks for an extension, triggers the translation and renders the results on screen.
 * 
 ***********************************************************************/
static void Verbs::UpdateActionBar() 
{
  // set the text in the action bar
  int action =  verbsData.global_action;
  verbsData.act_object = verbsData.inv_location;  
  verbsData.act_item = "";
  
  if (Mouse.Mode==eModeUseinv) { // use or give inventory item
    verbsData.act_item = player.ActiveInventory.Name;
    verbsData.location = verbsData.act_item;
    Verbs.RemoveExtension();
    verbsData.act_item = verbsData.location;
  }
  // if the mouse is in the inventory and modes Walk or pickup are selected
  else if (Verbs.GlobalCondition(eGlob_MouseInvWalk)) { 
      action = eGA_Use;
  }
  
  Verbs.TranslateAction(action, verbsData.lang);
  // show action text
  if (! verbsData.classicGui && verbsData.act_object == "" && action == eGA_WalkTo) lblAction.Text = " ";
  else lblAction.Text=verbsData.tresult;
  
  lblAction.TextColor = verbsData.actionLabelColorNormal;
  verbsData.actionLabelWidth = GetTextWidth(lblAction.Text, verbsData.fontTextOut) + 4; //+4 because GetTextWidth doesn't work too well with automatic outlined fonts
  
  if (lblAction.Width != verbsData.ScreenWidth) {   
    lblAction.Width = verbsData.ScreenWidth;
    lblAction.Y = verbsData.guiMain.Y - lblAction.Height;
  }
  
  // Show option button
//  if ( mouse.x > verbsData.ScreenWidth - btnShowOptions.Width +1 && mouse.y < btnShowOptions.Height +1 ) {
//    btnShowOptions.Visible = true;
//    verbsData.guiAction.Clickable = true;
//  }
//  else {
 //   verbsData.guiAction.Clickable = false;
 //   btnShowOptions.Visible = false;
 // }
  
}

/***********************************************************************
 * ToogleGuiStyle(int enable_new)
 * Switches between classic Scumm mode and new one.
 * 
 ***********************************************************************/
static void Verbs::ToogleGuiStyle(int enable_new)
{
  if (enable_new == 1) {
     verbsData.classicGui = false;
    Verbs.AdjustActionBarPosition();
  }
  else {
     verbsData.classicGui = true;
    lblAction.Width = verbsData.ScreenWidth;
    lblAction.X = 0;
    lblAction.Y = verbsData.guiMain.Y - lblAction.Height ;
  }
  Verbs.UpdateActionBar();
}
  

// ============================= translation ===========================================

/***********************************************************************
 * SetActionButtons(Action action, int btn_ID)
 * This functions connects the verb buttons with the action
 * 
 ***********************************************************************/
static void Verbs::SetActionButton(Action action, Button* btn)
{
  //Display("Mapping button %d of gui %d to action %d", btn.ID, btn.OwningGUI.ID, action);
  if (btn.OwningGUI.ID != verbsData.guiMain.ID) {
      AbortGame("This button is not part of the Verbs GUI.");
  }
  actionButtonData[action].action=action;
  actionButtonData[action].button=btn.ID;
}


/***********************************************************************
 * LocalizeActionButtons(int lang,  Action action, int sprite, int sprite_highlight, char key)
 * This fisused to assign / change the graphics of the verb buttons.
 * 
 ***********************************************************************/
static void Verbs::LocalizeActionButton(eLanguage lang,  Action action, int sprite, int sprite_highlight, char key)
{
  String upperkey = String.Format("%c", key);
  upperkey = upperkey.UpperCase();
  
  actionButtonData[action].button_graphic_normal[lang] = sprite;
  actionButtonData[action].button_graphic_highlight[lang] = sprite_highlight;
  actionButtonData[action].action_l_keycode[lang] = key;
  actionButtonData[action].action_u_keycode[lang] = upperkey.Chars[0];

}


/***********************************************************************
 * MapButtons() 
 * This sets up everything related to the verb buttons, so you need to take a look at this, if you want to customize your GUI. 
 * You can call SetActionButton in your own scripts to customize the default buttons mapping.
 * 
 ***********************************************************************/
static void Verbs::MapButtons() 
{
    Verbs.SetActionButton(eGA_Open,    verbsData.guiMain.Controls[0].AsButton);
    Verbs.SetActionButton(eGA_Close,   verbsData.guiMain.Controls[1].AsButton);
    Verbs.SetActionButton(eGA_GiveTo,  verbsData.guiMain.Controls[2].AsButton);
    Verbs.SetActionButton(eGA_PickUp,  verbsData.guiMain.Controls[3].AsButton);
    Verbs.SetActionButton(eGA_LookAt,  verbsData.guiMain.Controls[4].AsButton);
    Verbs.SetActionButton(eGA_TalkTo,  verbsData.guiMain.Controls[5].AsButton);
    Verbs.SetActionButton(eGA_Push,    verbsData.guiMain.Controls[6].AsButton);
    Verbs.SetActionButton(eGA_Pull,    verbsData.guiMain.Controls[7].AsButton);
    Verbs.SetActionButton(eGA_Use,     verbsData.guiMain.Controls[8].AsButton);
}


/***********************************************************************
 * SetKeys(int lang,  char key_yes, char key_no)
 * Lets you tell the module what should be the shortcuts for 'yes' and 'no'
 * 
 ***********************************************************************/
static void Verbs::SetKeys(eLanguage lang,  char key_yes, char key_no)
{
    String sYes = String.Format("%c", key_yes);
    String sNo = String.Format("%c", key_no);
    sYes = sYes.UpperCase();
    sNo = sNo.UpperCase();
    verbsData.key_u_yes[lang] = sYes.Chars[0];
    verbsData.key_u_no[lang] = sNo.Chars[0];
    sYes = sYes.LowerCase();
    sNo = sNo.LowerCase();
    verbsData.key_l_yes[lang] = sYes.Chars[0];
    verbsData.key_l_no[lang] = sNo.Chars[0];
}

  
  
/***********************************************************************
 * AdjustLanguage() 
 * This re-applies the buttons graphics and shortcuts accordingly to the language if you switch languages
 * 
 ***********************************************************************/
static void Verbs::Localize() 
{
  
  // English - eLangEN
    // yes/no-keys
    Verbs.SetKeys(eLangEN,  'y',  'n');
    
    Verbs.LocalizeActionButton(eLangEN,eGA_Open,    228, 241, 'o');
    Verbs.LocalizeActionButton(eLangEN,eGA_Close,   225, 238, 'c');
    Verbs.LocalizeActionButton(eLangEN,eGA_GiveTo,  226, 239, 'g');
    Verbs.LocalizeActionButton(eLangEN,eGA_PickUp,  229, 242, 'p');
    Verbs.LocalizeActionButton(eLangEN,eGA_LookAt,  227, 240, 'l');
    Verbs.LocalizeActionButton(eLangEN,eGA_TalkTo,  232, 245, 't');
    Verbs.LocalizeActionButton(eLangEN,eGA_Push,    231, 244, 's');
    Verbs.LocalizeActionButton(eLangEN,eGA_Pull,    230, 243, 'y');
    Verbs.LocalizeActionButton(eLangEN,eGA_Use,     233, 246, 'u');
    
  
  // German - eLangDE 
    // yes/no-keys
    Verbs.SetKeys(eLangDE,  'j',  'n');
    
    Verbs.LocalizeActionButton(eLangDE,eGA_Open,    94, 101, 'q');
    Verbs.LocalizeActionButton(eLangDE,eGA_Close,   102, 103, 'a');
    Verbs.LocalizeActionButton(eLangDE,eGA_GiveTo,  104, 105, 'y');
    Verbs.LocalizeActionButton(eLangDE,eGA_PickUp,  112, 113, 'w');
    Verbs.LocalizeActionButton(eLangDE,eGA_LookAt,  114, 115, 's');
    Verbs.LocalizeActionButton(eLangDE,eGA_TalkTo,  116, 117, 'x');
    Verbs.LocalizeActionButton(eLangDE,eGA_Push,    106, 107, 'e');
    Verbs.LocalizeActionButton(eLangDE,eGA_Pull,    108, 109, 'd');
    Verbs.LocalizeActionButton(eLangDE,eGA_Use,     110, 111, 'c');
  
  // Spanish - eLangES
    // yes/no-keys
    Verbs.SetKeys(eLangES,  's',  'n');
    
    Verbs.LocalizeActionButton(eLangES,eGA_Open,    141, 142, 'q');
    Verbs.LocalizeActionButton(eLangES,eGA_Close,   143, 144, 'a');
    Verbs.LocalizeActionButton(eLangES,eGA_GiveTo,  145, 146, 'z');
    Verbs.LocalizeActionButton(eLangES,eGA_PickUp,  153, 154, 'w');
    Verbs.LocalizeActionButton(eLangES,eGA_LookAt,  155, 156, 's');
    Verbs.LocalizeActionButton(eLangES,eGA_TalkTo,  157, 158, 'x');
    Verbs.LocalizeActionButton(eLangES,eGA_Push,    148, 147, 'e');
    Verbs.LocalizeActionButton(eLangES,eGA_Pull,    149, 150, 'd');
    Verbs.LocalizeActionButton(eLangES, eGA_Use,    151, 152, 'c');

  // French - eLangFR
    // yes/no-keys
    Verbs.SetKeys(eLangFR,  'o',  'n');
    
    Verbs.LocalizeActionButton(eLangFR, eGA_Open,    123, 124, 'a');
    Verbs.LocalizeActionButton(eLangFR, eGA_Close,   125, 126, 'q');
    Verbs.LocalizeActionButton(eLangFR, eGA_GiveTo,  127, 128, 'w');
    Verbs.LocalizeActionButton(eLangFR, eGA_PickUp,  135, 136, 'z');
    Verbs.LocalizeActionButton(eLangFR, eGA_LookAt,  137, 138, 's');
    Verbs.LocalizeActionButton(eLangFR, eGA_TalkTo,  139, 140, 'x');
    Verbs.LocalizeActionButton(eLangFR, eGA_Push,    129, 130, 'e');
    Verbs.LocalizeActionButton(eLangFR, eGA_Pull,    131, 132, 'd');
    Verbs.LocalizeActionButton(eLangFR, eGA_Use,     133, 134, 'c'); 
  
  // Italian - eLangIT
    // yes/no-keys
    Verbs.SetKeys(eLangIT,  's',  'n');   

    Verbs.LocalizeActionButton(eLangIT, eGA_Open,    159, 160, 'q');
    Verbs.LocalizeActionButton(eLangIT, eGA_Close,   161, 162, 'a');
    Verbs.LocalizeActionButton(eLangIT, eGA_GiveTo,  163, 164, 'z');
    Verbs.LocalizeActionButton(eLangIT, eGA_PickUp,  171, 172, 'w');
    Verbs.LocalizeActionButton(eLangIT, eGA_LookAt,  173, 174, 's');
    Verbs.LocalizeActionButton(eLangIT, eGA_TalkTo,  175, 176, 'x');
    Verbs.LocalizeActionButton(eLangIT, eGA_Push,    165, 166, 'e');
    Verbs.LocalizeActionButton(eLangIT, eGA_Pull,    167, 168, 'd');
    Verbs.LocalizeActionButton(eLangIT, eGA_Use,     169, 170, 'c'); 

  // Portuguese -  eLangPT
    // yes/no-keys
    Verbs.SetKeys(eLangPT,  's',  'n');   

    Verbs.LocalizeActionButton(eLangPT, eGA_Open,    177, 178, 'q');
    Verbs.LocalizeActionButton(eLangPT, eGA_Close,   179, 180, 'a');
    Verbs.LocalizeActionButton(eLangPT, eGA_GiveTo,  181, 182, 'z');
    Verbs.LocalizeActionButton(eLangPT, eGA_PickUp,  189, 190, 'w');
    Verbs.LocalizeActionButton(eLangPT, eGA_LookAt,  191, 192, 's');
    Verbs.LocalizeActionButton(eLangPT, eGA_TalkTo,  193, 194, 'x');
    Verbs.LocalizeActionButton(eLangPT, eGA_Push,    183, 184, 'e');
    Verbs.LocalizeActionButton(eLangPT, eGA_Pull,    185, 186, 'd');
    Verbs.LocalizeActionButton(eLangPT, eGA_Use,     187, 188, 'c'); 

  // Dutch - eLangNL
    // yes/no-keys
    Verbs.SetKeys(eLangNL,  'j',  'n');
    
    Verbs.LocalizeActionButton(eLangNL, eGA_Open,    195, 196, 'q');
    Verbs.LocalizeActionButton(eLangNL, eGA_Close,   197, 198, 'a');
    Verbs.LocalizeActionButton(eLangNL, eGA_GiveTo,  199, 200, 'z');
    Verbs.LocalizeActionButton(eLangNL, eGA_PickUp,  207, 208, 'w');
    Verbs.LocalizeActionButton(eLangNL, eGA_LookAt,  209, 210, 's');
    Verbs.LocalizeActionButton(eLangNL, eGA_TalkTo,  211, 212, 'x');
    Verbs.LocalizeActionButton(eLangNL, eGA_Push,    201, 202, 'e');
    Verbs.LocalizeActionButton(eLangNL, eGA_Pull,    203, 204, 'd');
    Verbs.LocalizeActionButton(eLangNL, eGA_Use,     205, 206, 'c');

  
}


/***********************************************************************
 * AdjustGUIText() 
 * This sets up the translation for the other GUI elements
 * 
 ***********************************************************************/
static void Verbs::AdjustGUIText() 
{
  bool custom_font;
  //int fontText    = verbsData.fontText;
  //int fontTextOut = verbsData.fontTextOut;
  //int fontSpeech  = verbsData.fontSpeech;
  //int fontSpeechOut = verbsData.fontOutlineSpeech;
  
  // English
  if (verbsData.lang == eLangEN){
    // English
    custom_font = false;
    /*
      // Just an example how you would define custom fonts:
      custom_font = true;
      fontText    = eFontLucasFan;
      fontTextOut = eFontLucasFanOut;    
    */
    //lblOptions.Text        = "Options";
   // lblOptionsMusic.Text   = "Music Volume";
   // lblOptionsSound.Text   = "Sound Effects Volume";
    //lblOptionsStyle.Text   = "Layout";
    //lblOptionsGuiClassic.Text   = "Classic";
   // lblOptionsGuiModern.Text    = "Modern";
    //btnOptionsDefault.Text = "Default";
  //  btnOptionsSave.Text    = "Save";
  //  btnOptionsLoad.Text    = "Load";
   // btnOptionsQuit.Text    = "Quit";
   // btnOptionsResume.Text  = "Resume";
    //lblPauseHeadline.Text  = "Game Paused";
    //lblPauseMessage.Text   = "Press <SPACE> to continue";
    //lblLoad.Text           = "Load";
    btnLoadCancel.Text     = "Cancel";
    lblSave.Text           = "Save";
    btnSaveCancel.Text     = "Cancel";
   // lblQuitHeadline.Text   = "Quit Game";
  //  lblQuitMessage.Text    = "Are you sure you want to quit?";
  //  btnQuitYes.Text        = "Yes";
  //  btnQuitNo.Text         = "No";
  }
 

  
  // Apply language dependend custom fonts if needed
  if (custom_font) {
    Game.SpeechFont   = verbsData.fontSpeech;
    Game.NormalFont   = verbsData.fontText;
    lblAction.Font    = verbsData.fontTextOut;
    //lblOptions.Font   = verbsData.fontText;
    //lblOptionsMusic.Font   = verbsData.fontText;
   // lblOptionsSound.Font   = verbsData.fontText;
    //lblOptionsStyle.Font   = verbsData.fontText;
   // lblOptionsGuiClassic.Font   = verbsData.fontTextOut;
   // lblOptionsGuiModern.Font    = verbsData.fontTextOut;
    //btnOptionsDefault.Font = verbsData.fontText;
  //  btnOptionsSave.Font    = verbsData.fontText;
    //btnOptionsLoad.Font    = verbsData.fontText;
    btnOptionsQuit.Font    = verbsData.fontText;
    btnOptionsResume.Font  = verbsData.fontText;
   // lblPauseHeadline.Font  = verbsData.fontText;
  //  lblPauseMessage.Font   = verbsData.fontText;
    lblLoad.Font           = verbsData.fontText;
    btnLoadCancel.Font     = verbsData.fontText;
    lblSave.Font           = verbsData.fontText;
    btnSaveCancel.Font     = verbsData.fontText;
   // lblQuitHeadline.Font   = verbsData.fontText;
   // lblQuitMessage.Font    = verbsData.fontText;
   // btnQuitYes.Font        = verbsData.fontText;
   // btnQuitNo.Font         = verbsData.fontText;
  }
}

/***********************************************************************
 * InitGuiLanguage() 
 * Assigns the buttons graphics to the GUI elements
 * 
 ***********************************************************************/
static void Verbs::InitGuiLanguage() 
{
  int lang = verbsData.lang;
  //Verbs.AdjustLanguage();
  int i;
  GUIControl*gc;
  Button*b;
  
  while (i < ACT_COUNT) {
    gc = verbsData.guiMain.Controls[actionButtonData[i].button];
    b =  gc.AsButton;
    b.NormalGraphic=actionButtonData[i].button_graphic_normal[lang];
    i++;
  }
}

// ============================= Player function ===========================================


/***********************************************************************
 * FreezePlayer() 
 * Use this function to prevent the player from moving by the following movement functions of the template.
 * 
 ***********************************************************************/
static void Verbs::FreezePlayer()
{
  verbsData.player_frozen = true;
}

/***********************************************************************
 * UnfreezePlayer() 
 * Use this function to undo the freeze_player function and let the characters move again.
 * 
 ***********************************************************************/
static void Verbs::UnfreezePlayer()
{
  verbsData.player_frozen = false;
}
  
/***********************************************************************
 * SetPlayer(Character*ch)  
 * Similar to the AGS function Character.SetAsPlayer(). The difference is, that make the previous character clickable again, whereas the new character gets unclickable.
 * 
 ***********************************************************************/
static void Verbs::SetPlayer(Character*ch) 
{ 
  int cameraX, cameraY;
#ifdef SCRIPT_API_v3507
  // TODO Use Camera instead of Viewport!
  Camera* cam = Game.Camera;
  cameraX = cam.X;
  cameraY = cam.Y;
#endif
#ifndef SCRIPT_API_v3507
  cameraX = GetViewportX();
  cameraY = GetViewportY();
#endif
  // if old and new player character are in the same room then scroll room
  if (player.Room==ch.Room) {
    int x = cameraX;
    int tx = ch.x - verbsData.ScreenWidth / 2;
    
    if (tx < 0) tx = 0;
    else if (tx > Room.Width - verbsData.ScreenWidth) tx = Room.Width - verbsData.ScreenWidth;
    
#ifdef SCRIPT_API_v3507
    cam.SetAt(x, cameraY);
#endif
#ifndef SCRIPT_API_v3507
    SetViewport(x, cameraY);
#endif

    while (x < tx) {
      x += verbsData.player_walk_x_speed;
      if (x > tx) x=tx;
      
#ifdef SCRIPT_API_v3507
      cam.SetAt(x, cameraY);
#endif
#ifndef SCRIPT_API_v3507
      SetViewport(x, cameraY);
#endif

      Wait(1);
    }
    while (x > tx) {
      x -= verbsData.player_walk_x_speed;
      if (x < tx) x=tx;
      
#ifdef SCRIPT_API_v3507
      cam.SetAt(x, cameraY);
#endif
#ifndef SCRIPT_API_v3507
      SetViewport(x, cameraY);
#endif

      Wait (1);
    }
#ifdef SCRIPT_API_v3507
    cam.AutoTracking = true;
#endif
#ifndef SCRIPT_API_v3507
    ReleaseViewport();
#endif
  }

  player.StopMoving();
  player.Clickable=true;
  ch.Clickable=false;
  ch.SetAsPlayer();
}

/***********************************************************************
 * MovePlayerEx(int x, int y, WalkWhere direct)
 * Move the player character to x,y coords, waiting until he/she gets there,
 * but allowing to cancel the action by pressing a mouse button.
 * Return values:
 * 0 = movement cancelled
 * 1 = not cancelled
 * 2 = reached the given coordinates
 * 
 ***********************************************************************/
static int Verbs::MovePlayerEx(int x, int y, WalkWhere direct) 
{
  bool movement_canceled = false;
  // Move the player character to x,y coords, waiting until he/she gets there,
  // but allowing to cancel the action by pressing a mouse button.
  if (verbsData.player_frozen == false) {
    player.Walk(x, y, eNoBlock, direct);
    // wait for release of mouse button
    while (player.Moving && (mouse.IsButtonDown(eMouseLeft) || mouse.IsButtonDown(eMouseRight))) {
      Wait(1);
      mouse.Update();
      Verbs.CheckDefaultAction();
    }
    // abort moving on new mouse down
    while (player.Moving) {
      int xm = mouse.x;
      int ym = mouse.y;
      InventoryItem*ii = InventoryItem.GetAtScreenXY(xm, ym);
      if (mouse.IsButtonDown(eMouseLeft) && (GUI.GetAtScreenXY(xm, ym)==null || ii!=null)) {
        player.StopMoving();
        movement_canceled = true;
      }
      else if (mouse.IsButtonDown(eMouseRight) && (GUI.GetAtScreenXY(xm, ym)==null || ii!=null)) {
        player.StopMoving();
        movement_canceled = true;
      }
      else {
        Wait(1);
        mouse.Update();
        Verbs.CheckDefaultAction ();
      }
    }
    if (!movement_canceled && player.x == x && player.y == y) return 2;
    else if (!movement_canceled) return 1;
    else return 0;
  }
  else return 0;
}

/***********************************************************************
 * MovePlayer(int x, int y)
 * Moves the player character around on walkable areas, a wrapper for MovePlayerEx.
 * 0 = movement cancelled
 * 1 = if the character has reached the given coordinates
 * 
 ***********************************************************************/
static int Verbs::MovePlayer(int x, int y) 
{
  if (gameStarted) //annoying fix for a critical bug caused by the title screen
  {
    //Move the player character to x,y coords, waiting until he/she gets there, but allowing to cancel the action
    //by pressing a mouse button.
    return Verbs.MovePlayerEx (x, y, eWalkableAreas);
  }
}


/***********************************************************************
 * GoToCharacterEx(Character*chwhogoes, Character*ch, CharacterDirection dir, int xoffset, int yoffset, bool NPCfacesplayer, int blocking)
 * Goes to a character staying at the side defined by ‘direction’: 1 up, 2 right, 3 down, 4 left and it stays at x-offset or y-offset from the character. 
 * blocking: 0=non-blocking; 1=blocking; 2=semi-blocking 
 * Returns 1, if the character has reached it’s goal and 0 if the movement has been cancelled before.
 * 
 ***********************************************************************/
static int Verbs::GoToCharacterEx(Character*chwhogoes, Character*ch, CharacterDirection dir, int xoffset, int yoffset, bool NPCfacesplayer, int blocking) 
{
  Character*pl = chwhogoes;
  int chx, chy;
  chx = ch.x;
  chy = ch.y;
  int arrived=1;
  if (Geometry.Offset(pl.x, chx) > xoffset || Geometry.Offset(pl.y, chy) > yoffset) {
    if (dir == 0) {
      // get the nearest position
      if (Geometry.Offset (chx, pl.x) >= Geometry.Offset(chy, pl.y)) {
        // right or left
        if (pl.x >= chx) dir = eDirectionRight;
        else dir = eDirectionLeft;
      }
      else {
        if (pl.y >= chy) dir = eDirectionDown; 
        else dir = eDirectionUp;
      }
    }
    // calculate target position
    if (dir == eDirectionUp)    chy-=yoffset;
    else if (dir == eDirectionRight) chx+=xoffset;
    else if (dir == eDirectionDown)  chy+=yoffset;
    else if (dir == eDirectionLeft)  chx-=xoffset;
    // move character
    if (blocking==0) {
      pl.Walk(chx, chy);
      arrived = 0;
    }
    else if (blocking==1) {
      pl.Walk(chx, chy, eBlock, eWalkableAreas);
      arrived=1;
    }
    else if (blocking==2) arrived=Verbs.MovePlayer(chx, chy);
  }
  if (arrived>0) {
    // characters only face each other after the moving character arrived at the target point
    if (NPCfacesplayer) ch.FaceCharacter(pl, eBlock);
    pl.FaceCharacter(ch, eBlock);
  }
  return arrived;
}

/***********************************************************************
 * NPCGoToCharacter(Character*chwhogoes, Character*chtogoto, CharacterDirection dir, bool NPCfacesplayer, int blocking)
 * The same as GoToCharacterEx, just with an default offset of x=35 and y=20 
 * blocking: 0=non-blocking; 1=blocking; 2=semi-blocking 
 * Returns 1, if the character has reached it’s goal and 0 if the movement has been cancelled before.
 * 
 ***********************************************************************/
static int Verbs::NPCGoToCharacter(Character*chwhogoes, Character*chtogoto, CharacterDirection dir, bool NPCfacesplayer, int blocking) 
{
  // same as above but with default x and y offset.
  int defaultxoffset = 35;
  int defaultyoffset = 20;
  return Verbs.GoToCharacterEx (chwhogoes, chtogoto, dir, defaultxoffset, defaultyoffset, NPCfacesplayer, blocking);
}

/***********************************************************************
 * GoToCharacter(Character*ch, CharacterDirection dir, bool NPCfacesplayer, int blocking)
 * The same as GoToCharacterEx, just with an default offset of x=35 and y=20 and the player character set as default
 * blocking: 0=non-blocking; 1=blocking; 2=semi-blocking 
 * Returns 1, if the character has reached it’s goal and 0 if the movement has been cancelled before.
 * 
 ***********************************************************************/
static int Verbs::GoToCharacter(Character*ch, CharacterDirection dir, bool NPCfacesplayer, int blocking) 
{
  // same as above but with default x and y offset.
  int defaultxoffset = 35;
  int defaultyoffset = 20;
  return Verbs.GoToCharacterEx (player, ch, dir, defaultxoffset, defaultyoffset, NPCfacesplayer, blocking);
}

/***********************************************************************
 * GoTo(int blocking)
 * Go to whatever the player clicked on. This function is used to intercept a walk-to event and check if the player has reached it’s goal. 
 * E.g. this is used in the exit extension processing. blocking: 0=non-blocking; 1=blocking; 2=semi-blocking
 * 
 ***********************************************************************/
static int Verbs::GoTo(int blocking) 
{
  int cameraX,  cameraY;
#ifdef SCRIPT_API_v3507
  Camera* cam = Game.Camera;
  cameraX = cam.X;
  cameraY = cam.Y;

#endif
#ifndef SCRIPT_API_v3507
  cameraX = GetViewportX();
  cameraY = GetViewportY();
#endif

  int xtogo, ytogo;
  int locationtype = GetLocationType(mouse.x, mouse.y);
  Hotspot* hot_spot = Hotspot.GetAtScreenXY(mouse.x, mouse.y);
  int arrived=0;
  
  if (locationtype==eLocationCharacter) {
    arrived = Verbs.GoToCharacter(Character.GetAtScreenXY(mouse.x, mouse.y), 0, false, blocking);
  }
  else {
    if (locationtype==eLocationHotspot && hot_spot.ID>0 && (hot_spot.WalkToX >0 || hot_spot.WalkToY > 0) ) {
      xtogo=hot_spot.WalkToX;
      ytogo=hot_spot.WalkToY;
    }
    else if (locationtype==eLocationObject) {
      Object*obj = Object.GetAtScreenXY(mouse.x, mouse.y);
      if (obj.Graphic > 0) xtogo = obj.X + (Game.SpriteWidth[obj.Graphic] / 2);
      else xtogo = obj.X;
      ytogo = obj.Y;
    }
    else {
      xtogo = mouse.x;
      ytogo = mouse.y;
    }
    
    xtogo += cameraX;
    ytogo += cameraY;
    
    if (blocking==0) player.Walk(xtogo, ytogo, eNoBlock);
   
    else if (blocking==1) {
      player.Walk(xtogo, ytogo, eBlock);
      arrived=1;
    }
    else if (blocking==2) arrived=Verbs.MovePlayer(xtogo, ytogo);
  }
  return arrived;
}

/***********************************************************************
 * SetApproachingChar(bool enable)
 * If set to true, the player walks to other chars before talking or giving items. 
 * This behaviour is initially defined in the guiscript, this function is used to change it during runtime.
 * 
 ***********************************************************************/
static void Verbs::SetApproachingChar(bool enable)
{
  // If set to true, the player walks to other chars before talking or giving items.
  verbsData.approachCharInteract = enable;
}

/***********************************************************************
 * WalkOffScreen()
 * Handles the action of hotspots with exit extension ('>e').
 * double click on hotspots/objects will make the player exit the room instantly
 * 
 ***********************************************************************/
static void Verbs::WalkOffScreen()
{
  
  // doubleclick
  if (Verbs.UsedAction(eGA_WalkTo)) {
    if ( verbsData.exitExtensionDoubleclick && DoubleClick.Event[eMouseLeft]) 
    {
      if (verbsData.location_type == eLocationHotspot) hotspot[verbsData.location_id].RunInteraction(eModeUsermode1);
      else if (verbsData.location_type == eLocationObject) object[verbsData.location_id].RunInteraction(eModeUsermode1);
      
    }
    else
    {
      if (Verbs.GoTo(2) ){
        int x = player.x, 
            y = player.y;
            
        int offset = verbsData.walkOffScreenOffset;
        int dir = Verbs.ExtensionEx(2,verbsData.location_clicked);
        
        if      (dir=='u') y -= offset;
        else if (dir=='d') y += offset;
        else if (dir=='l') x -= offset;
        else if (dir=='r') x += offset;
     
        
        if (Verbs.MovePlayerEx(x, y, eAnywhere) >0){
          if (verbsData.location_type == eLocationHotspot) hotspot[verbsData.location_id].RunInteraction(eModeUsermode1);
          else if (verbsData.location_type == eLocationObject) object[verbsData.location_id].RunInteraction(eModeUsermode1);        
        }
        
      }    
    } 
  }
}

/***********************************************************************
 * StartRunning()
 * Speeds up movement and animation speed of the player char
 * 
 ***********************************************************************/
static void Verbs::StartRunning()
{
  verbsData.player_is_running = true;

  if (verbsData.player_ani_speed <  verbsData.runSpeedupRate) player.AnimationSpeed  = 0;
  else player.AnimationSpeed = verbsData.player_ani_speed /  verbsData.runSpeedupRate;
  player.StopMoving();

  player.SetWalkSpeed(verbsData.player_walk_x_speed *  verbsData.runSpeedupRate, verbsData.player_walk_y_speed *  verbsData.runSpeedupRate);
}

/***********************************************************************
 * StopRunning()
 * If the player is still in 'running mode' this function sets
 * the movement and animation speed back to normal
 * 
 ***********************************************************************/
static void Verbs::StopRunning()
{
  if (verbsData.player_is_running) {
    verbsData.player_is_running = false;
    player.StopMoving();
    player.SetWalkSpeed(verbsData.player_walk_x_speed,  verbsData.player_walk_y_speed);
    player.AnimationSpeed = verbsData.player_ani_speed;
  }
    
}


// ============================= Unhandled Events ===========================================


/***********************************************************************
 * Unhandled(int door_script)
 *  Please check this section and replace the boring default values with your own.
 *  If you courious, how it all works, keep on reading this comment  ;-)
 * 
 * Check modes with: if(UsedAction(A_???)), check types by if(type==#). types:
 *  1   a hotspot
 *  2   a character
 *  3   an object
 *  4   an inventory item.
 *  5   inv. item on hotspot
 *  6   inv. item on character
 *  7   inv. item on object
 *  8   inv. item on inv. item
 * 
 *  You have the string "locationname" that is the name of
 *  what you clicked on, and the string "usedinvname" that is
 *  the name of the item that was used on where you clicked (only for types 5,6,7,8) 
 *
 ***********************************************************************/
static void Verbs::Unhandled(int door_script) 
{
  InventoryItem*ii = InventoryItem.GetAtScreenXY(mouse.x, mouse.y);
  int type=0;
  if (verbsData.location_type == eLocationHotspot)   type = 1;
  if (verbsData.location_type == eLocationCharacter) type = 2;
  if (verbsData.location_type == eLocationObject)    type = 3;
  
  String locationname;
  String usedinvname;
  
  verbsData.location = verbsData.location_clicked;
  Verbs.RemoveExtension();
  locationname= verbsData.location;
  
  if (ii!=null) type = 4;
  
  if ( verbsData.AGSCursorMode == eModeUseinv) {
    if (ii!=null) {
      usedinvname = ii.Name;
      verbsData.location = usedinvname;
      Verbs.RemoveExtension();
      usedinvname = verbsData.location;
      if (type>0) type+=4;
    }
  }
  if ( verbsData.AGSCursorMode != eModeUsermode2 && type != 0) {
    if (type==2 || type==6) player.FaceCharacter(character[verbsData.location_id], eBlock);

    // unhandled USE
    if (Verbs.UsedAction(eGA_Use)) {
      // use inv on inv
      if (type >= 5) player.Say(verbsData.unhandled_strings[eVerbGuiUnhandledUseInv]);
      // use
      else player.Say(verbsData.unhandled_strings[eVerbGuiUnhandledUse]);
    }
    
    // unhandled LOOK AT  
    else if (Verbs.UsedAction(eGA_LookAt)) {
      // look at hotspots, objects etc.
      if (type!=2) player.Say(String.Format(verbsData.unhandled_strings[eVerbGuiUnhandledLook], locationname));
      // look at characters
      else player.Say(String.Format(verbsData.unhandled_strings[eVerbGuiUnhandledLookChar], locationname)); 
    }
    
    // unhandled PUSH
    else if (Verbs.UsedAction(eGA_Push)) {
      // push everything except characters
      if (type!=2) player.Say(verbsData.unhandled_strings[eVerbGuiUnhandledPush]);
      // push characters
      else player.Say(String.Format(verbsData.unhandled_strings[eVerbGuiUnhandledPushChar], locationname));
    }
    
    // unhandled PULL
    else if (Verbs.UsedAction(eGA_Pull)){
      // pull everything except characters
      if (type!=2) player.Say(verbsData.unhandled_strings[eVerbGuiUnhandledPull]);
      // pull characters
      else player.Say(String.Format(verbsData.unhandled_strings[eVerbGuiUnhandledPullChar], locationname));
    }
    
    // unhandled CLOSE
    else if (Verbs.UsedAction(eGA_Close)){
      if (door_script == 1) player.Say(verbsData.unhandled_strings[eVerbGuiUnhandledCloseDoor]);
      else if (type == 2) player.Say(String.Format(verbsData.unhandled_strings[eVerbGuiUnhandledCloseChar], locationname));
      else player.Say(verbsData.unhandled_strings[eVerbGuiUnhandledClose]);
    }
    
    // unhandled OPEN
    else if (Verbs.UsedAction(eGA_Open)) {
      if (door_script == 1) player.Say(verbsData.unhandled_strings[eVerbGuiUnhandledOpenDoor]);
      else if (type ==2) player.Say(String.Format(verbsData.unhandled_strings[eVerbGuiUnhandledOpenChar], locationname));
      else player.Say(verbsData.unhandled_strings[eVerbGuiUnhandledOpen]);
    }
    
    // unhandled PICKUP
    else if (Verbs.UsedAction(eGA_PickUp)) {
      if (type!=2) player.Say(verbsData.unhandled_strings[eVerbGuiUnhandledPickup]);
      else player.Say(String.Format(verbsData.unhandled_strings[eVerbGuiUnhandledPickupChar], locationname) );
    }

    // unhandled TALK TO
    else if (Verbs.UsedAction(eGA_TalkTo)) {
      if (type==2) player.Say(String.Format(verbsData.unhandled_strings[eVerbGuiUnhandledTalkToChar], locationname));
      else player.Say(verbsData.unhandled_strings[eVerbGuiUnhandledTalkTo]);
    }
    
    // unhandled USE INV
    else if (Verbs.UsedAction(eGA_UseInv)) player.Say(verbsData.unhandled_strings[eVerbGuiUnhandledUseInv]);
    
    // unhandled GIVE
    else if (verbsData.ItemGiven != null) player.Say(verbsData.unhandled_strings[eVerbGuiUnhandledGive]);   
    
    // unhandled DEFAULT
    else if (type==4) player.Say(verbsData.unhandled_strings[eVerbGuiUnhandledDefault]);

  }
}

// ============================= interaction functions ===========================================

/***********************************************************************
 * EnterRoom(this Character*, int newRoom, int x, int y, CharacterDirection dir)
 * Similar to the AGS function Character.ChangeRoom. The difference is, that you can also define, 
 * it which direction the character should look. Using this function makes the character turn to the direction, mentioned above.
 * 
 ***********************************************************************/
void EnterRoom(this Character*, int newRoom, int x, int y, CharacterDirection dir) 
{
  this.ChangeRoom(newRoom, x, y);
  this.FaceDirection(dir);
}

/***********************************************************************
 * AnyClickMove(int x, int y, CharacterDirection dir) 
 * Moves the player character to the coordinates given in the parameters. 
 * If the player reaches the destination, it’s turns to the given direction. 
 * You can use this kind of functions (including the movePlayer function which is called by this function), 
 * to check if the player actually reached it’s destination.
 * Returns 1, if the character has reached it’s goal and 0 if the movement has been cancelled before. 
 * 
 ***********************************************************************/
static int Verbs::AnyClickMove(int x, int y, CharacterDirection dir) 
{
  int result = Verbs.MovePlayer(x, y);
  if (result) {
   player.FaceDirection(dir, eBlock);
  }
  return result;
}

/***********************************************************************
 * AnyClickWalk(int x, int y, CharacterDirection dir)
 * This function is almost similar to any_click_move. But it’s only called, if the current action is eMA_WalkTo. 
 * 
 ***********************************************************************/
static int Verbs::AnyClickWalk(int x, int y, CharacterDirection dir)
{
  int result=1;
  if (Verbs.UsedAction(eGA_WalkTo)) Verbs.AnyClickMove(x, y, dir);
  else result=0;
  return result;
}

/***********************************************************************
 * AnyClickWalkLook(int x, int y, CharacterDirection dir, String lookat)
 * This function moves the player character to the given location, turns it to the given direction and lets it say the message, given in the string.
 * 
 ***********************************************************************/
static int Verbs::AnyClickWalkLook(int x, int y, CharacterDirection dir, String lookat)
{
  int result=Verbs.AnyClickWalk(x, y, dir);
  if (result==0 && lookat.Length>0) {
    result=1;
    if (Verbs.AnyClickMove(x, y, dir)) {
      player.Say(lookat);
    }
  }
  return result;
}

/***********************************************************************
 * AnyClickUseInv(InventoryItem*iitem, int x, int y, CharacterDirection dir) 
 * This function moves the player to the given destination. 
 * It returns 0, if the action is unhandled, 1 is returned, if the action is handled, but has been cancelled. 
 * 2 is returned, if everything went fine.
 *
 ***********************************************************************/
static int Verbs::AnyClickUseInv(InventoryItem*iitem, int x, int y, CharacterDirection dir) 
{
  int result=0;
  if (Verbs.UsedAction(eGA_UseInv)) {
    if (player.ActiveInventory == iitem) {
      if (Verbs.AnyClickMove(x, y, dir)) result = 2;
      else result = 1;
    }
  }
  return result;

}

/***********************************************************************
 * AnyClickUseInv(InventoryItem*iitem, int x, int y, CharacterDirection dir) 
 * This function starts the same as any_click_walk_look. If an object ID > 0 has been given, this object is set invisible. 
 * Afterwards the inventory item is going to be added to the player’s inventory and if there’s an audioclip in the parameters, that one is played too. 
 * It returns 0, if the action is unhandled, 1 is returned, if the action is handled, but has been cancelled. 
 * 2 is returned, if the item was picked up
 *
 ***********************************************************************/
static int Verbs::AnyClickWalkLookPick(int x, int y, CharacterDirection dir, String lookat, int obj, InventoryItem*iitem, AudioClip *sound) 
{
  AudioChannel *chan;
  int result=Verbs.MovePlayer(x, y);
  
  if (result>0 && Verbs.UsedAction(eGA_PickUp)) {
    if (Verbs.AnyClickMove(x, y, dir)) {
      if (lookat.Length>0) player.Say(lookat);
      if (sound != null)chan = sound.Play();
      if (obj>=0) object[obj].Visible=false;
      if (iitem!=null) player.AddInventory(iitem);
      result=2;
    }
  }
  return result;
}

// ============================= Door functions ==========================================

/***********************************************************************
 * AnyClickSpecial(int door_id, int obj, int x, int y, CharacterDirection dir, int nr_room, int nr_x, int nr_y, CharacterDirection nr_dir, AudioClip *opensound, AudioClip *closesound, int key, int closevalue)
 * This function extends AnyClick with the following parameters:
 * 
 *   opensound: custom sound to be played, when the door is being opend 
 *   closesound: custom sound to be played, when the door is being closed 
 *   key: the id of the inventory item, that can unlock the door, -1 masterkey, -2 if the door cannot be unlocked 
 *   closevalue: default 0 (closed), but you can also set 2 (locked). 
 ***********************************************************************/
static int Doors::AnyClickSpecial(int door_id, int obj, int x, int y, CharacterDirection dir, int nr_room, int nr_x, int nr_y, CharacterDirection nr_dir, AudioClip *opensound, AudioClip *closesound, int key, int closevalue) {
  // key = -1: masterkey - even locked doors will be opened
  // key = -2: door can't be unlocked (like rusted) 
  AudioChannel *chan;
  int result=1;
  
  if (Verbs.UsedAction(eGA_Close)) {
    if (Doors.GetDoorState(door_id) == 0 || Doors.GetDoorState(door_id) == 2) Verbs.Unhandled(1);
    else if (Doors.GetDoorState(door_id) == 1 ) {
      if (Verbs.AnyClickMove(x, y, dir)) {
        if (closesound != null) chan = closesound.Play();
        // Play default sound
        else if (verbsData.closeDoorSound != null) chan = verbsData.closeDoorSound.Play();
        object[obj].Visible=false;
        Doors.SetDoorState(door_id, closevalue);
      }
    }
  }
  else if (Verbs.UsedAction(eGA_Open)) {
    if (Doors.GetDoorState(door_id) == 0 || (Doors.GetDoorState(door_id) == 2 && key == -1 ) ) {
      if (Verbs.AnyClickMove (x, y, dir))
      {
        if (opensound != null) chan = opensound.Play();
        // Play default sound
        else if (verbsData.openDoorSound != null) chan = verbsData.openDoorSound.Play();     
        
        object[obj].Visible=true;
        Doors.SetDoorState(door_id, 1);
      }
    }
    else if (Doors.GetDoorState(door_id) == 1 ) Verbs.Unhandled(1);
    else if (Doors.GetDoorState(door_id) == 2 ) {
      if (Verbs.AnyClickMove(x, y, dir)) if (!String.IsNullOrEmpty(verbsData.door_strings[eDoorStringLocked])) player.Say(verbsData.door_strings[eDoorStringLocked]);
    }
  }
  else if (Verbs.UsedAction(eGA_WalkTo)) {
    if (Doors.GetDoorState(door_id) == 1) {
      if ( verbsData.exitDoorDoubleclick && DoubleClick.Event[eMouseLeft] ) 
      {
        if (Verbs.MovePlayerEx(player.x, player.y, eWalkableAreas) > 0 ) player.EnterRoom(nr_room, nr_x, nr_y, nr_dir);
        result = 2;
      }
      else 
      {
        if (Verbs.GoTo(2)){
          player.EnterRoom(nr_room, nr_x, nr_y, nr_dir);
          result = 2;          
        }
        
      }
    }
    else Verbs.AnyClickMove(x, y, dir);

  }
  else if (Verbs.UsedAction (eGA_LookAt) && !String.IsNullOrEmpty(verbsData.door_strings[eDoorStringLookAt]) ) {
    if (Verbs.AnyClickMove (x, y, dir)) player.Say(verbsData.door_strings[eDoorStringLookAt]);
  }
  else if (Verbs.UsedAction(eGA_UseInv) && key >= 0) {
    if (Verbs.AnyClickMove(x, y, dir)) {
      if (player.ActiveInventory == inventory[key] ) {
        if (Doors.GetDoorState(door_id) == 1 ) { 
          if (!String.IsNullOrEmpty(verbsData.door_strings[eDoorStringCloseFirst]) ) player.Say(verbsData.door_strings[eDoorStringCloseFirst]);
        }
        else if (Doors.GetDoorState(door_id) == 2 ) {
          if (verbsData.unlockDoorSound != null) chan = verbsData.unlockDoorSound.Play();
          if (!String.IsNullOrEmpty(verbsData.door_strings[eDoorStringUnlock])) player.Say(verbsData.door_strings[eDoorStringUnlock]);
          Doors.SetDoorState(door_id, closevalue);
        } 
        else if (Doors.GetDoorState(door_id) == 0 ) {
          object[obj].Visible=false;
          Doors.SetDoorState(door_id, 2);
          if (!String.IsNullOrEmpty(verbsData.door_strings[eDoorStringRelock])) player.Say(verbsData.door_strings[eDoorStringRelock]);
        }
      }
      else if (!String.IsNullOrEmpty(verbsData.door_strings[eDoorStringWrongItem])) player.Say(verbsData.door_strings[eDoorStringWrongItem]);
    }
  }
  else result=0;
  
  return result;
  // 0 = unhandled
  // 1 = handled
  // 2 = NewRoom
}

/***********************************************************************
 * AnyClick(int door_id, int obj, int x, int y, CharacterDirection dir, int nr_room, int nr_x, int nr_y, CharacterDirection nr_dir)
 * This function is used in the room script in combination with the door hotspot. Parameters:
 * 
 *   door_id: The door id, you have defined 
 *   verbsData.act_object: The object, containing the open sprite 
 *   x,y: the walk-to point of the door (please don’t use the built in "walk-to coordinates" feature of the room editor. 
 *   dir: the direction, the player’s character should face, after it reached x,y 
 *   nr_room: if the door is opened and walking through it, the player is being send to this room 
 *   nr_x,nr_y: the x,y coordinates of inside of the new room 
 *   nr_dir: after the room change, the player faces this direction 
 *   This is the main function of the door scripts. With this you connect the hotspot with the door and the player’s action. 
 *
 * If you have defined default door sounds, these are also being called in this function. 
 * Also you can’t unlock a door with this function. You need AnyClickSpecial for that.
 ***********************************************************************/
static int Doors::AnyClick(int door_id, int obj, int x, int y, CharacterDirection dir, int nr_room, int nr_x, int nr_y, CharacterDirection nr_dir) {
  return Doors.AnyClickSpecial (door_id, obj, x, y, dir, nr_room, nr_x, nr_y, nr_dir, null, null, 0, 0);
}


// ============================= AGS internal functions ==========================================

/***********************************************************************
 * game_start()
 * 
 ***********************************************************************/
function game_start()
{
  verbsData.runSpeedupRate = 1;
  verbsData.player_ani_speed =  player.AnimationSpeed;
  verbsData.player_walk_x_speed = player.WalkSpeedX;
  verbsData.player_walk_y_speed = player.WalkSpeedY;
#ifdef SCRIPT_API_v3507
  verbsData.ScreenWidth = Screen.Width;
  verbsData.ScreenHeight = Screen.Height;
#endif
#ifndef SCRIPT_API_v3507
  verbsData.ScreenWidth = System.ScreenWidth;
  verbsData.ScreenHeight = System.ScreenHeight;
#endif
}

/***********************************************************************
 * on_event(EventType event, int data)
 * 
 ***********************************************************************/
function on_event(EventType event, int data)
{
  if (event == eEventEnterRoomBeforeFadein) {
    Verbs.CheckDefaultAction();
    Verbs.UpdateActionBar();
    Verbs.StopRunning();
  }
  
  else if (event==eEventRestoreGame) {
    //Verbs.AdjustLanguage();
    Verbs.InitGuiLanguage();
  }
}

/***********************************************************************
 * on_key_press(eKeyCode keycode)
 * 
 ***********************************************************************/
function on_key_press(eKeyCode keycode) 
{
 
if (gameStarted) { //don't do this until the game has actually started
   
  // Show pause gui on space-key
  
  if (gOptions.Visible == false && gQuit.Visible == false && gRestart.Visible == false && gThanksForPlaying.Visible == false)
  
  {
      
      if (keycode == eKeySpace)
      {
        if (!IsGamePaused()) {
          PauseGame();
          Verbs.AdjustGUIText();
          verbsData.guiPause.Visible=true;
        }
        else {
          verbsData.guiPause.Visible=false;
          UnPauseGame();
          Verbs.SetAction(eGA_Default);
          lblAction.TextColor=verbsData.actionLabelColorHighlighted;      
          Verbs.CheckDefaultAction();
          Verbs.UpdateActionBar();
        }
      }
  
}
  
  
}

  if (verbsData.guiQuit.Visible) {
    if (keycode==verbsData.key_u_no[verbsData.lang] || keycode==verbsData.key_l_no[verbsData.lang]) verbsData.guiQuit.Visible=false; 
    if (keycode==verbsData.key_u_yes[verbsData.lang] || keycode==verbsData.key_l_yes[verbsData.lang]) QuitGame(0);
  }
  
  if (gRestart.Visible) {
    if (keycode==verbsData.key_u_no[verbsData.lang] || keycode==verbsData.key_l_no[verbsData.lang]) gRestart.Visible=false; 
    if (keycode==verbsData.key_u_yes[verbsData.lang] || keycode==verbsData.key_l_yes[verbsData.lang]) RestartGame();
  }
  
  //  triggering actions by keyboard
  if (!IsGamePaused()) {
    int act_i=0;
    while (act_i < ACT_COUNT) {
      if (keycode == actionButtonData[act_i].action_l_keycode[verbsData.lang] || keycode==actionButtonData[act_i].action_u_keycode[verbsData.lang]) {
        Verbs.SetAction(act_i);
        act_i = ACT_COUNT;
      }
      else {
        act_i++;
      }
    }
  } 
}

/***********************************************************************
 * on_mouse_click(MouseButton button)
 * 
 ***********************************************************************/
function on_mouse_click(MouseButton button) {
  
  if (!Verbs.IsGuiDisabled()) {
    int x = mouse.x;
    int y = mouse.y;
    
    // get location under mouse cursor
    verbsData.location_type = GetLocationType(x, y);
    verbsData.location_clicked = Game.GetLocationName(x, y);

     verbsData.AGSCursorMode = Mouse.Mode;
     verbsData.used_action =  verbsData.global_action;
    
    InventoryItem*ii = InventoryItem.GetAtScreenXY(x, y);
    if (verbsData.location_type == eLocationHotspot) {
      Hotspot*h = Hotspot.GetAtScreenXY(x, y);
      verbsData.location_id=h.ID;
      
    }
    else if (verbsData.location_type == eLocationCharacter) {
      Character*c=Character.GetAtScreenXY(x, y);
      verbsData.location_id=c.ID;
    }
    else if (verbsData.location_type==eLocationObject) {
      Object*o=Object.GetAtScreenXY(x, y);
      verbsData.location_id=o.ID;
    }
    else if (ii!=null) verbsData.location_id=ii.ID;
    
    //dont allow endless running
    Verbs.StopRunning();
    
    
    if (IsGamePaused()) {
      // Game is paused, so do nothing (ie. don't allow mouse click)
    }
    // Mousebutton Left
    else if (button == eMouseLeft) 
    {

      if (Verbs.GlobalCondition(eGlob_InvOnInv) || Verbs.GlobalCondition(eGlob_GiveTalkNoChar) || Verbs.GlobalCondition(eGlob_GiveNoInv)) {
        // Do nothing, if:
        // the mode is useinv and the mouse is over the active inv (like "use knife on knife")
        // or the mode is talk, or "Give", and the mouse isnt over a character
        // or its GIVE and the mouse isnt over a inv.item        
        if ( verbsData.classicGui) {
        }
        // the modern GUI Style turns TalkTo and Give into the Default mode.
        else {
          if ( verbsData.AGSCursorMode==eModeTalkto ||  verbsData.AGSCursorMode == eModeInteract ) {
            Verbs.UpdateActionBar();
            lblAction.TextColor = verbsData.actionLabelColorHighlighted;
            Verbs.SetAction(eGA_Default);
            verbsData.ItemGiven=null;            
          }
          else {
          }
        }
      }
      else if (Verbs.ExtensionEx(1, verbsData.location_clicked)=='e') {
        Verbs.UpdateActionBar();
        lblAction.TextColor = verbsData.actionLabelColorHighlighted;
        Verbs.WalkOffScreen();
      }
      // walk to
      else if ( verbsData.AGSCursorMode == eModeUsermode2) {
        lblAction.TextColor=verbsData.actionLabelColorHighlighted;

        // Run on doubleclick
        if ( verbsData.runOnDoubleClick && DoubleClick.Event[eMouseLeft]) {
          Verbs.StartRunning();
        }

        if (IsInteractionAvailable(x, y,  verbsData.AGSCursorMode) ) {
          Room.ProcessClick (x, y,  verbsData.AGSCursorMode);
        }
        else {
          Room.ProcessClick (x, y, eModeWalkto);
        }

      }   
      // talkto
      else if ( verbsData.AGSCursorMode==eModeTalkto && IsInteractionAvailable(x, y,  verbsData.AGSCursorMode) && verbsData.location_type==eLocationCharacter) {
        lblAction.TextColor=verbsData.actionLabelColorHighlighted;
        Verbs.SetAction(eGA_Default);
        if (verbsData.approachCharInteract == false) character[verbsData.location_id].RunInteraction( verbsData.AGSCursorMode); 
        else {
          if (Verbs.GoToCharacter(character[verbsData.location_id], 0, verbsData.NPCfacingPlayer, 2)) character[verbsData.location_id].RunInteraction( verbsData.AGSCursorMode);
        }
            
      }
      // Giveto
      else if (( verbsData.AGSCursorMode == eModeUseinv) && verbsData.location_type==eLocationCharacter && Verbs.IsAction(eGA_GiveTo)) {
        lblAction.TextColor = verbsData.actionLabelColorHighlighted;
        verbsData.ItemGiven=player.ActiveInventory;
        Verbs.SetAction (eGA_Default);
        if (verbsData.approachCharInteract == false) {
          if (IsInteractionAvailable (x, y, eModeUseinv) == 1) {
            character[verbsData.location_id].RunInteraction(eModeUseinv);
          }
        }
        else {
          if (Verbs.GoToCharacter(character[verbsData.location_id], 0, verbsData.NPCfacingPlayer, 2)) {
            if (IsInteractionAvailable (x, y, eModeUseinv) == 1) {
              character[verbsData.location_id].RunInteraction(eModeUseinv);        
            }
          }
        }
        
      }     
      else {
        Verbs.UpdateActionBar();
        lblAction.TextColor = verbsData.actionLabelColorHighlighted;
        Room.ProcessClick(x, y,  verbsData.AGSCursorMode);
        Verbs.SetAction(eGA_Default);
        verbsData.ItemGiven=null;
      }
    }
    // Mousebutton Right
    else if (button==eMouseRight) {
      if ( verbsData.alternative_action==eGA_Default) {
        Verbs.SetAction(eGA_Default);
        lblAction.TextColor=verbsData.actionLabelColorHighlighted;
        
        if (Mouse.Mode==eModeUsermode2) {
          if (Verbs.ExtensionEx(1, verbsData.location_clicked)=='e') {
            Verbs.UpdateActionBar();
            lblAction.TextColor=verbsData.actionLabelColorHighlighted;
            Verbs.WalkOffScreen();
          }          
          else {
            Room.ProcessClick(x, y, eModeWalkto);
          }
        }
        else {
          Room.ProcessClick(x, y, Mouse.Mode);

        }
      }
      else {
        Verbs.SetAction( verbsData.alternative_action);
         verbsData.used_action= verbsData.global_action;
        Verbs.UpdateActionBar();
        lblAction.TextColor=verbsData.actionLabelColorHighlighted;
         verbsData.AGSCursorMode=Mouse.Mode;
        if ( verbsData.AGSCursorMode == eModeTalkto && IsInteractionAvailable(x, y,  verbsData.AGSCursorMode) && verbsData.location_type == eLocationCharacter) {
          if (verbsData.approachCharInteract == false) {
            character[verbsData.location_id].RunInteraction( verbsData.AGSCursorMode);
          }
          else {
            if (Verbs.GoToCharacter(character[verbsData.location_id], 0, verbsData.NPCfacingPlayer,2 )) character[verbsData.location_id].RunInteraction( verbsData.AGSCursorMode);   
          }
        }
        else {

          Room.ProcessClick(x, y,  verbsData.AGSCursorMode);
        }
        Verbs.SetAction(eGA_Default);
      }
      
    }
    //left click in inventory
    else if (button==eMouseLeftInv) {
      if (!Verbs.IsAction(eGA_GiveTo))verbsData.ItemGiven= null;
   
      if (Verbs.GlobalCondition (eGlob_MouseInvWalk)) {
        // if the mouse is in the inventory and modes Walk is selected
        Verbs.SetAction (eGA_Use);
        verbsData.location = verbsData.inv_ex_location;    
        if (Verbs.Extension()=='u' && ii.IsInteractionAvailable(eModeInteract)) {
          // use it immediately (not with anything else)
           verbsData.used_action =  verbsData.global_action;
          ii.RunInteraction(eModeInteract);
          Verbs.SetAction(eGA_Default);
        }
        else {
          player.ActiveInventory=ii;
        }
      } 
      else  if (Verbs.GlobalCondition(eGlob_InvOnInv)) {
        // if the mode is useinv and the mouse is over the active inv (like "use knife on knife")
        // so do nothing again
      }
      else {
         verbsData.used_action =  verbsData.global_action;
        if (Mouse.Mode == eModeInteract && ii != null) {
          if (Verbs.IsAction(eGA_Use) && ii.IsInteractionAvailable(eModeInteract)) {
            lblAction.TextColor=verbsData.actionLabelColorHighlighted;
            ii.RunInteraction(eModeInteract);
            Verbs.SetAction(eGA_Default);
          }
          else player.ActiveInventory=ii;
        }
        else {
          if ( (Mouse.Mode >0 && Mouse.Mode <10 )&& ii != null) {
             verbsData.AGSCursorMode=Mouse.Mode;
            lblAction.TextColor = verbsData.actionLabelColorHighlighted;
            ii.RunInteraction(Mouse.Mode);
            Verbs.SetAction(eGA_Default);
          }
        }
      }
    }
    //right click in inventory
    else if (button==eMouseRightInv) {
      if ( verbsData.alternative_action==eGA_Default) {
        Verbs.SetAction(eGA_Default);
      }
      else {
        Verbs.SetAction( verbsData.alternative_action);
         verbsData.used_action= verbsData.global_action;
         verbsData.AGSCursorMode=Mouse.Mode;
        if (Mouse.Mode==eModeInteract && ii != null) {
          if (Verbs.IsAction(eGA_Use) && ii.IsInteractionAvailable(eModeInteract)) {
            Verbs.UpdateActionBar();
            lblAction.TextColor = verbsData.actionLabelColorHighlighted;
            ii.RunInteraction(eModeInteract);
            Verbs.SetAction(eGA_Default);
          }
          else player.ActiveInventory=ii;
        }
        else {
          Verbs.UpdateActionBar();
          lblAction.TextColor = verbsData.actionLabelColorHighlighted;
          inventory[game.inv_activated].RunInteraction(Mouse.Mode);
          Verbs.SetAction(eGA_Default);
        }
      }
    }
  }
  else {
    Room.ProcessClick(mouse.x, mouse.y, Mouse.Mode);
  }
}

/***********************************************************************
 * repeatedly_execute()
 * 
 ***********************************************************************/
function repeatedly_execute() {

  if (!IsGamePaused() && !Verbs.IsGuiDisabled())
  {
    
    if ( verbsData.classicGui == true) {
      Verbs.CheckDefaultAction();
      Verbs.UpdateActionBar(); 
    }
    Verbs.HandleInvArrows();
  
  
    // Keep running, if mouse is pressed
    if (verbsData.player_is_running && mouse.IsButtonDown(eMouseLeft)) {
#ifdef SCRIPT_API_v3507
      Point *mouse_pt = Screen.ScreenToRoomPoint(mouse.x, mouse.y);
      int mx = mouse_pt.x;
      int my = mouse_pt.y;
#endif
#ifndef SCRIPT_API_v3507
      int mx = mouse.x + GetViewportX();
      int my = mouse.y + GetViewportY();
#endif
      int px = player.x;
      int py = player.y;
      int dist  = FloatToInt(Geometry.Distance(mx, my, px, py), eRoundDown);
      
      if (!player.Moving) {
        // Running on an exit or door
        if (dist <=  verbsData.runCursorDistance && (Verbs.ExtensionEx(1,  verbsData.location_ex)=='e' || Verbs.ExtensionEx(1,  verbsData.location_ex)=='v')) {
          //Verbs.StopRunning(); // Should not be needed, since this is now handled in the roomechange event
          Verbs.UpdateActionBar();
          lblAction.TextColor = verbsData.actionLabelColorHighlighted;
          Room.ProcessClick(mouse.x, mouse.y, eModeUsermode1);      
        }
        // else keep running while left mouse button pressed
        else if (dist >  verbsData.runCursorDistance ) {
          player.Walk(mx, my, eNoBlock);
        }
      }
    }
    // turn off running if player stops walking
    else if (verbsData.player_is_running && !player.Moving && !mouse.IsButtonDown(eMouseLeft)) {
      Verbs.StopRunning();
    }
  }
}

/***********************************************************************
 * repeatedly_execute_always()
 * 
 ***********************************************************************/
function repeatedly_execute_always() {
  
  
  if (!IsGamePaused() && !Verbs.IsGuiDisabled()) {
  
    // Update Actionbar
    if ( verbsData.classicGui == false) {
      Verbs.CheckDefaultAction();

      // Update Actionbar after command is executed
      if (verbsData.location_clicked != null && verbsData.location_clicked.Length > 0) {
        if (verbsData.location_clicked.IndexOf(">") > 0) verbsData.temp_location = verbsData.location_clicked.Truncate(verbsData.location_clicked.IndexOf(">"));
        else verbsData.temp_location = verbsData.location_clicked;
      }
      else verbsData.temp_location = "";

      if (IsInterfaceEnabled() || verbsData.temp_location != verbsData.location || verbsData.location == "") {
        Verbs.UpdateActionBar();
        verbsData.location_clicked = "";
      }
      Verbs.AdjustActionBarPosition();
    }
  }
}
